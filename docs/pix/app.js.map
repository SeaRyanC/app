{
  "version": 3,
  "sources": ["../../pix/node_modules/preact/src/constants.js", "../../pix/node_modules/preact/src/util.js", "../../pix/node_modules/preact/src/options.js", "../../pix/node_modules/preact/src/create-element.js", "../../pix/node_modules/preact/src/component.js", "../../pix/node_modules/preact/src/diff/props.js", "../../pix/node_modules/preact/src/create-context.js", "../../pix/node_modules/preact/src/diff/children.js", "../../pix/node_modules/preact/src/diff/index.js", "../../pix/node_modules/preact/src/render.js", "../../pix/node_modules/preact/src/clone-element.js", "../../pix/node_modules/preact/src/diff/catch-error.js", "../../pix/node_modules/preact/hooks/src/index.js", "../../pix/src/colors.ts", "../../pix/src/floodFill.ts", "../../pix/src/regions.ts", "../../pix/src/grid.ts", "../../pix/src/state.ts", "../../pix/node_modules/preact/jsx-runtime/src/utils.js", "../../pix/node_modules/preact/src/constants.js", "../../pix/node_modules/preact/jsx-runtime/src/index.js", "../../pix/src/app.tsx"],
  "sourcesContent": ["/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Indicates that this node needs to be inserted while patching children */\nexport const INSERT_VNODE = 1 << 2;\n/** Indicates a VNode has been matched with another VNode in the diff */\nexport const MATCHED = 1 << 1;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(MODE_HYDRATE | MODE_SUSPENDED);\n\nexport const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\nexport const XHTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\nexport const MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n\nexport const NULL = null;\nexport const UNDEFINED = undefined;\nexport const EMPTY_OBJ = /** @type {any} */ ({});\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL =\n\t/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n", "import { EMPTY_ARR } from './constants';\n\nexport const isArray = Array.isArray;\n\n/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\t// @ts-expect-error We change the type of `obj` to be `O & P`\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {import('./index').ContainerNode} node The node to remove\n */\nexport function removeNode(node) {\n\tif (node && node.parentNode) node.parentNode.removeChild(node);\n}\n\nexport const slice = EMPTY_ARR.slice;\n", "import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n", "import { slice } from './util';\nimport options from './options';\nimport { NULL, UNDEFINED } from './constants';\n\nlet vnodeId = 0;\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component constructor for this\n * virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the\n * virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != NULL) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === UNDEFINED) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, NULL);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\t/** @type {import('./internal').VNode} */\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: NULL,\n\t\t_parent: NULL,\n\t\t_depth: 0,\n\t\t_dom: NULL,\n\t\t_component: NULL,\n\t\tconstructor: UNDEFINED,\n\t\t_original: original == NULL ? ++vnodeId : original,\n\t\t_index: -1,\n\t\t_flags: 0\n\t};\n\n\t// Only invoke the vnode hook if this was *not* a direct copy:\n\tif (original == NULL && options.vnode != NULL) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: NULL };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != NULL && vnode.constructor === UNDEFINED;\n", "import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\nimport { MODE_HYDRATE, NULL } from './constants';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function BaseComponent(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {import('./internal').Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nBaseComponent.prototype.setState = function (update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != NULL && this._nextState != this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == NULL) return;\n\n\tif (this._vnode) {\n\t\tif (callback) {\n\t\t\tthis._stateCallbacks.push(callback);\n\t\t}\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {import('./internal').Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nBaseComponent.prototype.forceUpdate = function (callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](https://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {ComponentChildren | void}\n */\nBaseComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == NULL) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._index + 1)\n\t\t\t: NULL;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != NULL && sibling._dom != NULL) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : NULL;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {import('./internal').Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet oldVNode = component._vnode,\n\t\toldDom = oldVNode._dom,\n\t\tcommitQueue = [],\n\t\trefQueue = [];\n\n\tif (component._parentDom) {\n\t\tconst newVNode = assign({}, oldVNode);\n\t\tnewVNode._original = oldVNode._original + 1;\n\t\tif (options.vnode) options.vnode(newVNode);\n\n\t\tdiff(\n\t\t\tcomponent._parentDom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tcomponent._parentDom.namespaceURI,\n\t\t\toldVNode._flags & MODE_HYDRATE ? [oldDom] : NULL,\n\t\t\tcommitQueue,\n\t\t\toldDom == NULL ? getDomSibling(oldVNode) : oldDom,\n\t\t\t!!(oldVNode._flags & MODE_HYDRATE),\n\t\t\trefQueue\n\t\t);\n\n\t\tnewVNode._original = oldVNode._original;\n\t\tnewVNode._parent._children[newVNode._index] = newVNode;\n\t\tcommitRoot(commitQueue, newVNode, refQueue);\n\t\toldVNode._dom = oldVNode._parent = null;\n\n\t\tif (newVNode._dom != oldDom) {\n\t\t\tupdateParentDomPointers(newVNode);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./internal').VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != NULL && vnode._component != NULL) {\n\t\tvnode._dom = vnode._component.base = NULL;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != NULL && child._dom != NULL) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Component>}\n */\nlet rerenderQueue = [];\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/**\n * Enqueue a rerender of a component\n * @param {import('./internal').Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce != options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/**\n * @param {import('./internal').Component} a\n * @param {import('./internal').Component} b\n */\nconst depthSort = (a, b) => a._vnode._depth - b._vnode._depth;\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet c,\n\t\tl = 1;\n\n\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t// process() calls from getting scheduled while `queue` is still being consumed.\n\twhile (rerenderQueue.length) {\n\t\t// Keep the rerender queue sorted by (depth, insertion order). The queue\n\t\t// will initially be sorted on the first iteration only if it has more than 1 item.\n\t\t//\n\t\t// New items can be added to the queue e.g. when rerendering a provider, so we want to\n\t\t// keep the order from top to bottom with those new items so we can handle them in a\n\t\t// single pass\n\t\tif (rerenderQueue.length > l) {\n\t\t\trerenderQueue.sort(depthSort);\n\t\t}\n\n\t\tc = rerenderQueue.shift();\n\t\tl = rerenderQueue.length;\n\n\t\tif (c._dirty) {\n\t\t\trenderComponent(c);\n\t\t}\n\t}\n\tprocess._rerenderCount = 0;\n}\n\nprocess._rerenderCount = 0;\n", "import { IS_NON_DIMENSIONAL, NULL, SVG_NAMESPACE } from '../constants';\nimport options from '../options';\n\nfunction setStyle(style, key, value) {\n\tif (key[0] == '-') {\n\t\tstyle.setProperty(key, value == NULL ? '' : value);\n\t} else if (value == NULL) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\nconst CAPTURE_REGEX = /(PointerCapture)$|Capture$/i;\n\n// A logical clock to solve issues like https://github.com/preactjs/preact/issues/3927.\n// When the DOM performs an event it leaves micro-ticks in between bubbling up which means that\n// an event can trigger on a newly reated DOM-node while the event bubbles up.\n//\n// Originally inspired by Vue\n// (https://github.com/vuejs/core/blob/caeb8a68811a1b0f79/packages/runtime-dom/src/modules/events.ts#L90-L101),\n// but modified to use a logical clock instead of Date.now() in case event handlers get attached\n// and events get dispatched during the same millisecond.\n//\n// The clock is incremented after each new event dispatch. This allows 1 000 000 new events\n// per second for over 280 years before the value reaches Number.MAX_SAFE_INTEGER (2**53 - 1).\nlet eventClock = 0;\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {string} namespace Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, namespace) {\n\tlet useCapture;\n\n\to: if (name == 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style.cssText = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] != oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] == 'o' && name[1] == 'n') {\n\t\tuseCapture = name != (name = name.replace(CAPTURE_REGEX, '$1'));\n\t\tconst lowerCaseName = name.toLowerCase();\n\n\t\t// Infer correct casing for DOM built-in events:\n\t\tif (lowerCaseName in dom || name == 'onFocusOut' || name == 'onFocusIn')\n\t\t\tname = lowerCaseName.slice(2);\n\t\telse name = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) {\n\t\t\t\tvalue._attached = eventClock;\n\t\t\t\tdom.addEventListener(\n\t\t\t\t\tname,\n\t\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\t\tuseCapture\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tvalue._attached = oldValue._attached;\n\t\t\t}\n\t\t} else {\n\t\t\tdom.removeEventListener(\n\t\t\t\tname,\n\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\tuseCapture\n\t\t\t);\n\t\t}\n\t} else {\n\t\tif (namespace == SVG_NAMESPACE) {\n\t\t\t// Normalize incorrect prop usage for SVG:\n\t\t\t// - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\n\t\t\t// - className --> class\n\t\t\tname = name.replace(/xlink(H|:h)/, 'h').replace(/sName$/, 's');\n\t\t} else if (\n\t\t\tname != 'width' &&\n\t\t\tname != 'height' &&\n\t\t\tname != 'href' &&\n\t\t\tname != 'list' &&\n\t\t\tname != 'form' &&\n\t\t\t// Default value in browsers is `-1` and an empty string is\n\t\t\t// cast to `0` instead\n\t\t\tname != 'tabIndex' &&\n\t\t\tname != 'download' &&\n\t\t\tname != 'rowSpan' &&\n\t\t\tname != 'colSpan' &&\n\t\t\tname != 'role' &&\n\t\t\tname != 'popover' &&\n\t\t\tname in dom\n\t\t) {\n\t\t\ttry {\n\t\t\t\tdom[name] = value == NULL ? '' : value;\n\t\t\t\t// labelled break is 1b smaller here than a return statement (sorry)\n\t\t\t\tbreak o;\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\t// aria- and data- attributes have no boolean representation.\n\t\t// A `false` value is different from the attribute not being\n\t\t// present, so we can't remove it. For non-boolean aria\n\t\t// attributes we could treat false as a removal, but the\n\t\t// amount of exceptions would cost too many bytes. On top of\n\t\t// that other frameworks generally stringify `false`.\n\n\t\tif (typeof value == 'function') {\n\t\t\t// never serialize functions as attribute values\n\t\t} else if (value != NULL && (value !== false || name[4] == '-')) {\n\t\t\tdom.setAttribute(name, name == 'popover' && value == true ? '' : value);\n\t\t} else {\n\t\t\tdom.removeAttribute(name);\n\t\t}\n\t}\n}\n\n/**\n * Create an event proxy function.\n * @param {boolean} useCapture Is the event handler for the capture phase.\n * @private\n */\nfunction createEventProxy(useCapture) {\n\t/**\n\t * Proxy an event to hooked event handlers\n\t * @param {import('../internal').PreactEvent} e The event object from the browser\n\t * @private\n\t */\n\treturn function (e) {\n\t\tif (this._listeners) {\n\t\t\tconst eventHandler = this._listeners[e.type + useCapture];\n\t\t\tif (e._dispatched == NULL) {\n\t\t\t\te._dispatched = eventClock++;\n\n\t\t\t\t// When `e._dispatched` is smaller than the time when the targeted event\n\t\t\t\t// handler was attached we know we have bubbled up to an element that was added\n\t\t\t\t// during patching the DOM.\n\t\t\t} else if (e._dispatched < eventHandler._attached) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn eventHandler(options.event ? options.event(e) : e);\n\t\t}\n\t};\n}\n\nconst eventProxy = createEventProxy(false);\nconst eventProxyCapture = createEventProxy(true);\n", "import { enqueueRender } from './component';\nimport { NULL } from './constants';\n\nexport let i = 0;\n\nexport function createContext(defaultValue) {\n\tfunction Context(props) {\n\t\tif (!this.getChildContext) {\n\t\t\t/** @type {Set<import('./internal').Component> | null} */\n\t\t\tlet subs = new Set();\n\t\t\tlet ctx = {};\n\t\t\tctx[Context._id] = this;\n\n\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\tthis.componentWillUnmount = () => {\n\t\t\t\tsubs = NULL;\n\t\t\t};\n\n\t\t\tthis.shouldComponentUpdate = function (_props) {\n\t\t\t\t// @ts-expect-error even\n\t\t\t\tif (this.props.value != _props.value) {\n\t\t\t\t\tsubs.forEach(c => {\n\t\t\t\t\t\tc._force = true;\n\t\t\t\t\t\tenqueueRender(c);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.sub = c => {\n\t\t\t\tsubs.add(c);\n\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\tif (subs) {\n\t\t\t\t\t\tsubs.delete(c);\n\t\t\t\t\t}\n\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\n\t\treturn props.children;\n\t}\n\n\tContext._id = '__cC' + i++;\n\tContext._defaultValue = defaultValue;\n\n\t/** @type {import('./internal').FunctionComponent} */\n\tContext.Consumer = (props, contextValue) => {\n\t\treturn props.children(contextValue);\n\t};\n\n\t// we could also get rid of _contextRef entirely\n\tContext.Provider =\n\t\tContext._contextRef =\n\t\tContext.Consumer.contextType =\n\t\t\tContext;\n\n\treturn Context;\n}\n", "import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport {\n\tEMPTY_OBJ,\n\tEMPTY_ARR,\n\tINSERT_VNODE,\n\tMATCHED,\n\tUNDEFINED,\n\tNULL\n} from '../constants';\nimport { isArray } from '../util';\nimport { getDomSibling } from '../component';\n\n/**\n * @typedef {import('../internal').ComponentChildren} ComponentChildren\n * @typedef {import('../internal').Component} Component\n * @typedef {import('../internal').PreactElement} PreactElement\n * @typedef {import('../internal').VNode} VNode\n */\n\n/**\n * Diff the children of a virtual node\n * @param {PreactElement} parentDom The DOM element whose children are being\n * diffed\n * @param {ComponentChildren[]} renderResult\n * @param {VNode} newParentVNode The new virtual node whose children should be\n * diff'ed against oldParentVNode\n * @param {VNode} oldParentVNode The old virtual node whose children should be\n * diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\tlet i,\n\t\t/** @type {VNode} */\n\t\toldVNode,\n\t\t/** @type {VNode} */\n\t\tchildVNode,\n\t\t/** @type {PreactElement} */\n\t\tnewDom,\n\t\t/** @type {PreactElement} */\n\t\tfirstChildDom;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\t/** @type {VNode[]} */\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet newChildrenLength = renderResult.length;\n\n\toldDom = constructNewChildrenArray(\n\t\tnewParentVNode,\n\t\trenderResult,\n\t\toldChildren,\n\t\toldDom,\n\t\tnewChildrenLength\n\t);\n\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\tchildVNode = newParentVNode._children[i];\n\t\tif (childVNode == NULL) continue;\n\n\t\t// At this point, constructNewChildrenArray has assigned _index to be the\n\t\t// matchingIndex for this VNode's oldVNode (or -1 if there is no oldVNode).\n\t\tif (childVNode._index == -1) {\n\t\t\toldVNode = EMPTY_OBJ;\n\t\t} else {\n\t\t\toldVNode = oldChildren[childVNode._index] || EMPTY_OBJ;\n\t\t}\n\n\t\t// Update childVNode._index to its final index\n\t\tchildVNode._index = i;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tlet result = diff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\n\t\t// Adjust DOM nodes\n\t\tnewDom = childVNode._dom;\n\t\tif (childVNode.ref && oldVNode.ref != childVNode.ref) {\n\t\t\tif (oldVNode.ref) {\n\t\t\t\tapplyRef(oldVNode.ref, NULL, childVNode);\n\t\t\t}\n\t\t\trefQueue.push(\n\t\t\t\tchildVNode.ref,\n\t\t\t\tchildVNode._component || newDom,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t}\n\n\t\tif (firstChildDom == NULL && newDom != NULL) {\n\t\t\tfirstChildDom = newDom;\n\t\t}\n\n\t\tlet shouldPlace = !!(childVNode._flags & INSERT_VNODE);\n\t\tif (shouldPlace || oldVNode._children === childVNode._children) {\n\t\t\toldDom = insert(childVNode, oldDom, parentDom, shouldPlace);\n\t\t} else if (typeof childVNode.type == 'function' && result !== UNDEFINED) {\n\t\t\toldDom = result;\n\t\t} else if (newDom) {\n\t\t\toldDom = newDom.nextSibling;\n\t\t}\n\n\t\t// Unset diffing flags\n\t\tchildVNode._flags &= ~(INSERT_VNODE | MATCHED);\n\t}\n\n\tnewParentVNode._dom = firstChildDom;\n\n\treturn oldDom;\n}\n\n/**\n * @param {VNode} newParentVNode\n * @param {ComponentChildren[]} renderResult\n * @param {VNode[]} oldChildren\n */\nfunction constructNewChildrenArray(\n\tnewParentVNode,\n\trenderResult,\n\toldChildren,\n\toldDom,\n\tnewChildrenLength\n) {\n\t/** @type {number} */\n\tlet i;\n\t/** @type {VNode} */\n\tlet childVNode;\n\t/** @type {VNode} */\n\tlet oldVNode;\n\n\tlet oldChildrenLength = oldChildren.length,\n\t\tremainingOldChildren = oldChildrenLength;\n\n\tlet skew = 0;\n\n\tnewParentVNode._children = new Array(newChildrenLength);\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\t// @ts-expect-error We are reusing the childVNode variable to hold both the\n\t\t// pre and post normalized childVNode\n\t\tchildVNode = renderResult[i];\n\n\t\tif (\n\t\t\tchildVNode == NULL ||\n\t\t\ttypeof childVNode == 'boolean' ||\n\t\t\ttypeof childVNode == 'function'\n\t\t) {\n\t\t\tnewParentVNode._children[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (\n\t\t\ttypeof childVNode == 'string' ||\n\t\t\ttypeof childVNode == 'number' ||\n\t\t\t// eslint-disable-next-line valid-typeof\n\t\t\ttypeof childVNode == 'bigint' ||\n\t\t\tchildVNode.constructor == String\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tNULL,\n\t\t\t\tchildVNode,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL\n\t\t\t);\n\t\t} else if (isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL\n\t\t\t);\n\t\t} else if (childVNode.constructor === UNDEFINED && childVNode._depth > 0) {\n\t\t\t// VNode is already in use, clone it. This can happen in the following\n\t\t\t// scenario:\n\t\t\t//   const reuse = <div />\n\t\t\t//   <div>{reuse}<span />{reuse}</div>\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tchildVNode.ref ? childVNode.ref : NULL,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tnewParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\tconst skewedIndex = i + skew;\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\t// Temporarily store the matchingIndex on the _index property so we can pull\n\t\t// out the oldVNode in diffChildren. We'll override this to the VNode's\n\t\t// final index after using this property to get the oldVNode\n\t\tconst matchingIndex = (childVNode._index = findMatchingIndex(\n\t\t\tchildVNode,\n\t\t\toldChildren,\n\t\t\tskewedIndex,\n\t\t\tremainingOldChildren\n\t\t));\n\n\t\toldVNode = NULL;\n\t\tif (matchingIndex != -1) {\n\t\t\toldVNode = oldChildren[matchingIndex];\n\t\t\tremainingOldChildren--;\n\t\t\tif (oldVNode) {\n\t\t\t\toldVNode._flags |= MATCHED;\n\t\t\t}\n\t\t}\n\n\t\t// Here, we define isMounting for the purposes of the skew diffing\n\t\t// algorithm. Nodes that are unsuspending are considered mounting and we detect\n\t\t// this by checking if oldVNode._original == null\n\t\tconst isMounting = oldVNode == NULL || oldVNode._original == NULL;\n\n\t\tif (isMounting) {\n\t\t\tif (matchingIndex == -1) {\n\t\t\t\t// When the array of children is growing we need to decrease the skew\n\t\t\t\t// as we are adding a new element to the array.\n\t\t\t\t// Example:\n\t\t\t\t// [1, 2, 3] --> [0, 1, 2, 3]\n\t\t\t\t// oldChildren   newChildren\n\t\t\t\t//\n\t\t\t\t// The new element is at index 0, so our skew is 0,\n\t\t\t\t// we need to decrease the skew as we are adding a new element.\n\t\t\t\t// The decrease will cause us to compare the element at position 1\n\t\t\t\t// with value 1 with the element at position 0 with value 0.\n\t\t\t\t//\n\t\t\t\t// A linear concept is applied when the array is shrinking,\n\t\t\t\t// if the length is unchanged we can assume that no skew\n\t\t\t\t// changes are needed.\n\t\t\t\tif (newChildrenLength > oldChildrenLength) {\n\t\t\t\t\tskew--;\n\t\t\t\t} else if (newChildrenLength < oldChildrenLength) {\n\t\t\t\t\tskew++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we are mounting a DOM VNode, mark it for insertion\n\t\t\tif (typeof childVNode.type != 'function') {\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t} else if (matchingIndex != skewedIndex) {\n\t\t\t// When we move elements around i.e. [0, 1, 2] --> [1, 0, 2]\n\t\t\t// --> we diff 1, we find it at position 1 while our skewed index is 0 and our skew is 0\n\t\t\t//     we set the skew to 1 as we found an offset.\n\t\t\t// --> we diff 0, we find it at position 0 while our skewed index is at 2 and our skew is 1\n\t\t\t//     this makes us increase the skew again.\n\t\t\t// --> we diff 2, we find it at position 2 while our skewed index is at 4 and our skew is 2\n\t\t\t//\n\t\t\t// this becomes an optimization question where currently we see a 1 element offset as an insertion\n\t\t\t// or deletion i.e. we optimize for [0, 1, 2] --> [9, 0, 1, 2]\n\t\t\t// while a more than 1 offset we see as a swap.\n\t\t\t// We could probably build heuristics for having an optimized course of action here as well, but\n\t\t\t// might go at the cost of some bytes.\n\t\t\t//\n\t\t\t// If we wanted to optimize for i.e. only swaps we'd just do the last two code-branches and have\n\t\t\t// only the first item be a re-scouting and all the others fall in their skewed counter-part.\n\t\t\t// We could also further optimize for swaps\n\t\t\tif (matchingIndex == skewedIndex - 1) {\n\t\t\t\tskew--;\n\t\t\t} else if (matchingIndex == skewedIndex + 1) {\n\t\t\t\tskew++;\n\t\t\t} else {\n\t\t\t\tif (matchingIndex > skewedIndex) {\n\t\t\t\t\tskew--;\n\t\t\t\t} else {\n\t\t\t\t\tskew++;\n\t\t\t\t}\n\n\t\t\t\t// Move this VNode's DOM if the original index (matchingIndex) doesn't\n\t\t\t\t// match the new skew index (i + new skew)\n\t\t\t\t// In the former two branches we know that it matches after skewing\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove remaining oldChildren if there are any. Loop forwards so that as we\n\t// unmount DOM from the beginning of the oldChildren, we can adjust oldDom to\n\t// point to the next child, which needs to be the first DOM node that won't be\n\t// unmounted.\n\tif (remainingOldChildren) {\n\t\tfor (i = 0; i < oldChildrenLength; i++) {\n\t\t\toldVNode = oldChildren[i];\n\t\t\tif (oldVNode != NULL && (oldVNode._flags & MATCHED) == 0) {\n\t\t\t\tif (oldVNode._dom == oldDom) {\n\t\t\t\t\toldDom = getDomSibling(oldVNode);\n\t\t\t\t}\n\n\t\t\t\tunmount(oldVNode, oldVNode);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn oldDom;\n}\n\n/**\n * @param {VNode} parentVNode\n * @param {PreactElement} oldDom\n * @param {PreactElement} parentDom\n * @param {boolean} shouldPlace\n * @returns {PreactElement}\n */\nfunction insert(parentVNode, oldDom, parentDom, shouldPlace) {\n\t// Note: VNodes in nested suspended trees may be missing _children.\n\n\tif (typeof parentVNode.type == 'function') {\n\t\tlet children = parentVNode._children;\n\t\tfor (let i = 0; children && i < children.length; i++) {\n\t\t\tif (children[i]) {\n\t\t\t\t// If we enter this code path on sCU bailout, where we copy\n\t\t\t\t// oldVNode._children to newVNode._children, we need to update the old\n\t\t\t\t// children's _parent pointer to point to the newVNode (parentVNode\n\t\t\t\t// here).\n\t\t\t\tchildren[i]._parent = parentVNode;\n\t\t\t\toldDom = insert(children[i], oldDom, parentDom, shouldPlace);\n\t\t\t}\n\t\t}\n\n\t\treturn oldDom;\n\t} else if (parentVNode._dom != oldDom) {\n\t\tif (shouldPlace) {\n\t\t\tif (oldDom && parentVNode.type && !oldDom.parentNode) {\n\t\t\t\toldDom = getDomSibling(parentVNode);\n\t\t\t}\n\t\t\tparentDom.insertBefore(parentVNode._dom, oldDom || NULL);\n\t\t}\n\t\toldDom = parentVNode._dom;\n\t}\n\n\tdo {\n\t\toldDom = oldDom && oldDom.nextSibling;\n\t} while (oldDom != NULL && oldDom.nodeType == 8);\n\n\treturn oldDom;\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {ComponentChildren} children The unflattened children of a virtual\n * node\n * @returns {VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == NULL || typeof children == 'boolean') {\n\t} else if (isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\n/**\n * @param {VNode} childVNode\n * @param {VNode[]} oldChildren\n * @param {number} skewedIndex\n * @param {number} remainingOldChildren\n * @returns {number}\n */\nfunction findMatchingIndex(\n\tchildVNode,\n\toldChildren,\n\tskewedIndex,\n\tremainingOldChildren\n) {\n\tconst key = childVNode.key;\n\tconst type = childVNode.type;\n\tlet oldVNode = oldChildren[skewedIndex];\n\tconst matched = oldVNode != NULL && (oldVNode._flags & MATCHED) == 0;\n\n\t// We only need to perform a search if there are more children\n\t// (remainingOldChildren) to search. However, if the oldVNode we just looked\n\t// at skewedIndex was not already used in this diff, then there must be at\n\t// least 1 other (so greater than 1) remainingOldChildren to attempt to match\n\t// against. So the following condition checks that ensuring\n\t// remainingOldChildren > 1 if the oldVNode is not already used/matched. Else\n\t// if the oldVNode was null or matched, then there could needs to be at least\n\t// 1 (aka `remainingOldChildren > 0`) children to find and compare against.\n\t//\n\t// If there is an unkeyed functional VNode, that isn't a built-in like our Fragment,\n\t// we should not search as we risk re-using state of an unrelated VNode. (reverted for now)\n\tlet shouldSearch =\n\t\t// (typeof type != 'function' || type === Fragment || key) &&\n\t\tremainingOldChildren > (matched ? 1 : 0);\n\n\tif (\n\t\t(oldVNode === NULL && key == null) ||\n\t\t(matched && key == oldVNode.key && type == oldVNode.type)\n\t) {\n\t\treturn skewedIndex;\n\t} else if (shouldSearch) {\n\t\tlet x = skewedIndex - 1;\n\t\tlet y = skewedIndex + 1;\n\t\twhile (x >= 0 || y < oldChildren.length) {\n\t\t\tconst childIndex = x >= 0 ? x-- : y++;\n\t\t\toldVNode = oldChildren[childIndex];\n\t\t\tif (\n\t\t\t\toldVNode != NULL &&\n\t\t\t\t(oldVNode._flags & MATCHED) == 0 &&\n\t\t\t\tkey == oldVNode.key &&\n\t\t\t\ttype == oldVNode.type\n\t\t\t) {\n\t\t\t\treturn childIndex;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n", "import {\n\tEMPTY_OBJ,\n\tMATH_NAMESPACE,\n\tMODE_HYDRATE,\n\tMODE_SUSPENDED,\n\tNULL,\n\tRESET_MODE,\n\tSVG_NAMESPACE,\n\tUNDEFINED,\n\tXHTML_NAMESPACE\n} from '../constants';\nimport { BaseComponent, getDomSibling } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren } from './children';\nimport { setProperty } from './props';\nimport { assign, isArray, removeNode, slice } from '../util';\nimport options from '../options';\n\n/**\n * @typedef {import('../internal').ComponentChildren} ComponentChildren\n * @typedef {import('../internal').Component} Component\n * @typedef {import('../internal').PreactElement} PreactElement\n * @typedef {import('../internal').VNode} VNode\n */\n\n/**\n * @template {any} T\n * @typedef {import('../internal').Ref<T>} Ref<T>\n */\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {PreactElement} parentDom The parent of the DOM element\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\t/** @type {any} */\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== UNDEFINED) return NULL;\n\n\t// If the previous diff bailed out, resume creating/hydrating.\n\tif (oldVNode._flags & MODE_SUSPENDED) {\n\t\tisHydrating = !!(oldVNode._flags & MODE_HYDRATE);\n\t\toldDom = newVNode._dom = oldVNode._dom;\n\t\texcessDomChildren = [oldDom];\n\t}\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\touter: if (typeof newType == 'function') {\n\t\ttry {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\t\t\tconst isClassComponent =\n\t\t\t\t'prototype' in newType && newType.prototype.render;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif (isClassComponent) {\n\t\t\t\t\t// @ts-expect-error The check above verifies that newType is suppose to be constructed\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-expect-error Trust me, Component implements the interface we want\n\t\t\t\t\tnewVNode._component = c = new BaseComponent(\n\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (isClassComponent && c._nextState == NULL) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\n\t\t\tif (isClassComponent && newType.getDerivedStateFromProps != NULL) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\t\t\tc._vnode = newVNode;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tisClassComponent &&\n\t\t\t\t\tnewType.getDerivedStateFromProps == NULL &&\n\t\t\t\t\tc.componentWillMount != NULL\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (isClassComponent && c.componentDidMount != NULL) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tisClassComponent &&\n\t\t\t\t\tnewType.getDerivedStateFromProps == NULL &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != NULL\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tnewVNode._original == oldVNode._original ||\n\t\t\t\t\t(!c._force &&\n\t\t\t\t\t\tc.shouldComponentUpdate != NULL &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false)\n\t\t\t\t) {\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original != oldVNode._original) {\n\t\t\t\t\t\t// When we are dealing with a bail because of sCU we have to update\n\t\t\t\t\t\t// the props, state and dirty-state.\n\t\t\t\t\t\t// when we are dealing with strict-equality we don't as the child could still\n\t\t\t\t\t\t// be dirtied see #3883\n\t\t\t\t\t\tc.props = newProps;\n\t\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t\tc._dirty = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tnewVNode._children.some(vnode => {\n\t\t\t\t\t\tif (vnode) vnode._parent = newVNode;\n\t\t\t\t\t});\n\n\t\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t\t}\n\t\t\t\t\tc._stateCallbacks = [];\n\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != NULL) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (isClassComponent && c.componentDidUpdate != NULL) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc._parentDom = parentDom;\n\t\t\tc._force = false;\n\n\t\t\tlet renderHook = options._render,\n\t\t\t\tcount = 0;\n\t\t\tif (isClassComponent) {\n\t\t\t\tc.state = c._nextState;\n\t\t\t\tc._dirty = false;\n\n\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t}\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tc._dirty = false;\n\t\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\t\t// Handle setState called in render, see #2553\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t} while (c._dirty && ++count < 25);\n\t\t\t}\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != NULL) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (isClassComponent && !isNew && c.getSnapshotBeforeUpdate != NULL) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != NULL && tmp.type === Fragment && tmp.key == NULL;\n\t\t\tlet renderResult = tmp;\n\n\t\t\tif (isTopLevelFragment) {\n\t\t\t\trenderResult = cloneNode(tmp.props.children);\n\t\t\t}\n\n\t\t\toldDom = diffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tisArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnamespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\t\tnewVNode._flags &= RESET_MODE;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = NULL;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tnewVNode._original = NULL;\n\t\t\t// if hydrating or creating initial tree, bailout preserves DOM:\n\t\t\tif (isHydrating || excessDomChildren != NULL) {\n\t\t\t\tif (e.then) {\n\t\t\t\t\tnewVNode._flags |= isHydrating\n\t\t\t\t\t\t? MODE_HYDRATE | MODE_SUSPENDED\n\t\t\t\t\t\t: MODE_SUSPENDED;\n\n\t\t\t\t\twhile (oldDom && oldDom.nodeType == 8 && oldDom.nextSibling) {\n\t\t\t\t\t\toldDom = oldDom.nextSibling;\n\t\t\t\t\t}\n\n\t\t\t\t\texcessDomChildren[excessDomChildren.indexOf(oldDom)] = NULL;\n\t\t\t\t\tnewVNode._dom = oldDom;\n\t\t\t\t} else {\n\t\t\t\t\tfor (let i = excessDomChildren.length; i--; ) {\n\t\t\t\t\t\tremoveNode(excessDomChildren[i]);\n\t\t\t\t\t}\n\t\t\t\t\tmarkAsForce(newVNode);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\tif (!e.then) markAsForce(newVNode);\n\t\t\t}\n\t\t\toptions._catchError(e, newVNode, oldVNode);\n\t\t}\n\t} else if (\n\t\texcessDomChildren == NULL &&\n\t\tnewVNode._original == oldVNode._original\n\t) {\n\t\tnewVNode._children = oldVNode._children;\n\t\tnewVNode._dom = oldVNode._dom;\n\t} else {\n\t\toldDom = newVNode._dom = diffElementNodes(\n\t\t\toldVNode._dom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\t}\n\n\tif ((tmp = options.diffed)) tmp(newVNode);\n\n\treturn newVNode._flags & MODE_SUSPENDED ? undefined : oldDom;\n}\n\nfunction markAsForce(vnode) {\n\tif (vnode && vnode._component) vnode._component._force = true;\n\tif (vnode && vnode._children) vnode._children.forEach(markAsForce);\n}\n\n/**\n * @param {Array<Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {VNode} root\n */\nexport function commitRoot(commitQueue, root, refQueue) {\n\tfor (let i = 0; i < refQueue.length; i++) {\n\t\tapplyRef(refQueue[i], refQueue[++i], refQueue[++i]);\n\t}\n\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\t// @ts-expect-error Reuse the commitQueue variable here so the type changes\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\t// @ts-expect-error See above comment on commitQueue\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\nfunction cloneNode(node) {\n\tif (\n\t\ttypeof node != 'object' ||\n\t\tnode == NULL ||\n\t\t(node._depth && node._depth > 0)\n\t) {\n\t\treturn node;\n\t}\n\n\tif (isArray(node)) {\n\t\treturn node.map(cloneNode);\n\t}\n\n\treturn assign({}, node);\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {PreactElement} dom The DOM element representing the virtual nodes\n * being diffed\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n * @returns {PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating,\n\trefQueue\n) {\n\tlet oldProps = oldVNode.props || EMPTY_OBJ;\n\tlet newProps = newVNode.props;\n\tlet nodeType = /** @type {string} */ (newVNode.type);\n\t/** @type {any} */\n\tlet i;\n\t/** @type {{ __html?: string }} */\n\tlet newHtml;\n\t/** @type {{ __html?: string }} */\n\tlet oldHtml;\n\t/** @type {ComponentChildren} */\n\tlet newChildren;\n\tlet value;\n\tlet inputValue;\n\tlet checked;\n\n\t// Tracks entering and exiting namespaces when descending through the tree.\n\tif (nodeType == 'svg') namespace = SVG_NAMESPACE;\n\telse if (nodeType == 'math') namespace = MATH_NAMESPACE;\n\telse if (!namespace) namespace = XHTML_NAMESPACE;\n\n\tif (excessDomChildren != NULL) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tvalue = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tvalue &&\n\t\t\t\t'setAttribute' in value == !!nodeType &&\n\t\t\t\t(nodeType ? value.localName == nodeType : value.nodeType == 3)\n\t\t\t) {\n\t\t\t\tdom = value;\n\t\t\t\texcessDomChildren[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == NULL) {\n\t\tif (nodeType == NULL) {\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tdom = document.createElementNS(\n\t\t\tnamespace,\n\t\t\tnodeType,\n\t\t\tnewProps.is && newProps\n\t\t);\n\n\t\t// we are creating a new node, so we can assume this is a new subtree (in\n\t\t// case we are hydrating), this deopts the hydrate\n\t\tif (isHydrating) {\n\t\t\tif (options._hydrationMismatch)\n\t\t\t\toptions._hydrationMismatch(newVNode, excessDomChildren);\n\t\t\tisHydrating = false;\n\t\t}\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = NULL;\n\t}\n\n\tif (nodeType == NULL) {\n\t\t// During hydration, we still have to split merged text from SSR'd HTML.\n\t\tif (oldProps !== newProps && (!isHydrating || dom.data != newProps)) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\t// If excessDomChildren was not null, repopulate it with the current element's children:\n\t\texcessDomChildren = excessDomChildren && slice.call(dom.childNodes);\n\n\t\t// If we are in a situation where we are not hydrating but are using\n\t\t// existing DOM (e.g. replaceNode) we should read the existing DOM\n\t\t// attributes to diff them\n\t\tif (!isHydrating && excessDomChildren != NULL) {\n\t\t\toldProps = {};\n\t\t\tfor (i = 0; i < dom.attributes.length; i++) {\n\t\t\t\tvalue = dom.attributes[i];\n\t\t\t\toldProps[value.name] = value.value;\n\t\t\t}\n\t\t}\n\n\t\tfor (i in oldProps) {\n\t\t\tvalue = oldProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\toldHtml = value;\n\t\t\t} else if (!(i in newProps)) {\n\t\t\t\tif (\n\t\t\t\t\t(i == 'value' && 'defaultValue' in newProps) ||\n\t\t\t\t\t(i == 'checked' && 'defaultChecked' in newProps)\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsetProperty(dom, i, NULL, value, namespace);\n\t\t\t}\n\t\t}\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tfor (i in newProps) {\n\t\t\tvalue = newProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t\tnewChildren = value;\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\tnewHtml = value;\n\t\t\t} else if (i == 'value') {\n\t\t\t\tinputValue = value;\n\t\t\t} else if (i == 'checked') {\n\t\t\t\tchecked = value;\n\t\t\t} else if (\n\t\t\t\t(!isHydrating || typeof value == 'function') &&\n\t\t\t\toldProps[i] !== value\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, value, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\tif (\n\t\t\t\t!isHydrating &&\n\t\t\t\t(!oldHtml ||\n\t\t\t\t\t(newHtml.__html != oldHtml.__html && newHtml.__html != dom.innerHTML))\n\t\t\t) {\n\t\t\t\tdom.innerHTML = newHtml.__html;\n\t\t\t}\n\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\tif (oldHtml) dom.innerHTML = '';\n\n\t\t\tdiffChildren(\n\t\t\t\t// @ts-expect-error\n\t\t\t\tnewVNode.type == 'template' ? dom.content : dom,\n\t\t\t\tisArray(newChildren) ? newChildren : [newChildren],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnodeType == 'foreignObject' ? XHTML_NAMESPACE : namespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\texcessDomChildren\n\t\t\t\t\t? excessDomChildren[0]\n\t\t\t\t\t: oldVNode._children && getDomSibling(oldVNode, 0),\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\t// Remove children that are not part of any vnode.\n\t\t\tif (excessDomChildren != NULL) {\n\t\t\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\t\t\tremoveNode(excessDomChildren[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// As above, don't diff props during hydration\n\t\tif (!isHydrating) {\n\t\t\ti = 'value';\n\t\t\tif (nodeType == 'progress' && inputValue == NULL) {\n\t\t\t\tdom.removeAttribute('value');\n\t\t\t} else if (\n\t\t\t\tinputValue != UNDEFINED &&\n\t\t\t\t// #2756 For the <progress>-element the initial value is 0,\n\t\t\t\t// despite the attribute not being present. When the attribute\n\t\t\t\t// is missing the progress bar is treated as indeterminate.\n\t\t\t\t// To fix that we'll always update it when it is 0 for progress elements\n\t\t\t\t(inputValue !== dom[i] ||\n\t\t\t\t\t(nodeType == 'progress' && !inputValue) ||\n\t\t\t\t\t// This is only for IE 11 to fix <select> value not being updated.\n\t\t\t\t\t// To avoid a stale select value we need to set the option.value\n\t\t\t\t\t// again, which triggers IE11 to re-evaluate the select value\n\t\t\t\t\t(nodeType == 'option' && inputValue != oldProps[i]))\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, inputValue, oldProps[i], namespace);\n\t\t\t}\n\n\t\t\ti = 'checked';\n\t\t\tif (checked != UNDEFINED && checked != dom[i]) {\n\t\t\t\tsetProperty(dom, i, checked, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {Ref<any> & { _unmount?: unknown }} ref\n * @param {any} value\n * @param {VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') {\n\t\t\tlet hasRefUnmount = typeof ref._unmount == 'function';\n\t\t\tif (hasRefUnmount) {\n\t\t\t\t// @ts-ignore TS doesn't like moving narrowing checks into variables\n\t\t\t\tref._unmount();\n\t\t\t}\n\n\t\t\tif (!hasRefUnmount || value != NULL) {\n\t\t\t\t// Store the cleanup function on the function\n\t\t\t\t// instance object itself to avoid shape\n\t\t\t\t// transitioning vnode\n\t\t\t\tref._unmount = ref(value);\n\t\t\t}\n\t\t} else ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {VNode} vnode The virtual node to unmount\n * @param {VNode} parentVNode The parent of the VNode that initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current == vnode._dom) {\n\t\t\tapplyRef(r, NULL, parentVNode);\n\t\t}\n\t}\n\n\tif ((r = vnode._component) != NULL) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = NULL;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) {\n\t\t\t\tunmount(\n\t\t\t\t\tr[i],\n\t\t\t\t\tparentVNode,\n\t\t\t\t\tskipRemove || typeof vnode.type != 'function'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!skipRemove) {\n\t\tremoveNode(vnode._dom);\n\t}\n\n\tvnode._component = vnode._parent = vnode._dom = UNDEFINED;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n", "import { EMPTY_OBJ, NULL } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\nimport { slice } from './util';\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to render into\n * @param {import('./internal').PreactElement | object} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\t// https://github.com/preactjs/preact/issues/3794\n\tif (parentDom == document) {\n\t\tparentDom = document.documentElement;\n\t}\n\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we are in\n\t// hydration mode or not by passing the `hydrate` function instead of a DOM\n\t// element..\n\tlet isHydrating = typeof replaceNode == 'function';\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? NULL\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\n\tvnode = ((!isHydrating && replaceNode) || parentDom)._children =\n\t\tcreateElement(Fragment, NULL, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [],\n\t\trefQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\tvnode,\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.namespaceURI,\n\t\t!isHydrating && replaceNode\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t\t? NULL\n\t\t\t\t: parentDom.firstChild\n\t\t\t\t\t? slice.call(parentDom.childNodes)\n\t\t\t\t\t: NULL,\n\t\tcommitQueue,\n\t\t!isHydrating && replaceNode\n\t\t\t? replaceNode\n\t\t\t: oldVNode\n\t\t\t\t? oldVNode._dom\n\t\t\t\t: parentDom.firstChild,\n\t\tisHydrating,\n\t\trefQueue\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode, refQueue);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, hydrate);\n}\n", "import { assign, slice } from './util';\nimport { createVNode } from './create-element';\nimport { NULL, UNDEFINED } from './constants';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its\n * children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Any additional arguments will be used\n * as replacement children.\n * @returns {import('./internal').VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\n\tlet defaultProps;\n\n\tif (vnode.type && vnode.type.defaultProps) {\n\t\tdefaultProps = vnode.type.defaultProps;\n\t}\n\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse if (props[i] === UNDEFINED && defaultProps != UNDEFINED) {\n\t\t\tnormalizedProps[i] = defaultProps[i];\n\t\t} else {\n\t\t\tnormalizedProps[i] = props[i];\n\t\t}\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tNULL\n\t);\n}\n", "import { NULL } from '../constants';\n\n/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').VNode} vnode The vnode that threw the error that was caught (except\n * for unmounting when this parameter is the highest parent that was being\n * unmounted)\n * @param {import('../internal').VNode} [oldVNode]\n * @param {import('../internal').ErrorInfo} [errorInfo]\n */\nexport function _catchError(error, vnode, oldVNode, errorInfo) {\n\t/** @type {import('../internal').Component} */\n\tlet component,\n\t\t/** @type {import('../internal').ComponentType} */\n\t\tctor,\n\t\t/** @type {boolean} */\n\t\thandled;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tctor = component.constructor;\n\n\t\t\t\tif (ctor && ctor.getDerivedStateFromError != NULL) {\n\t\t\t\t\tcomponent.setState(ctor.getDerivedStateFromError(error));\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != NULL) {\n\t\t\t\t\tcomponent.componentDidCatch(error, errorInfo || {});\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\t// This is an error boundary. Mark it as having bailed out, and whether it was mid-hydration.\n\t\t\t\tif (handled) {\n\t\t\t\t\treturn (component._pendingError = component);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n", "import { options as _options } from 'preact';\n\n/** @type {number} */\nlet currentIndex;\n\n/** @type {import('./internal').Component} */\nlet currentComponent;\n\n/** @type {import('./internal').Component} */\nlet previousComponent;\n\n/** @type {number} */\nlet currentHook = 0;\n\n/** @type {Array<import('./internal').Component>} */\nlet afterPaintEffects = [];\n\n// Cast to use internal Options type\nconst options = /** @type {import('./internal').Options} */ (_options);\n\nlet oldBeforeDiff = options._diff;\nlet oldBeforeRender = options._render;\nlet oldAfterDiff = options.diffed;\nlet oldCommit = options._commit;\nlet oldBeforeUnmount = options.unmount;\nlet oldRoot = options._root;\n\n// We take the minimum timeout for requestAnimationFrame to ensure that\n// the callback is invoked after the next frame. 35ms is based on a 30hz\n// refresh rate, which is the minimum rate for a smooth user experience.\nconst RAF_TIMEOUT = 35;\nlet prevRaf;\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._diff = vnode => {\n\tcurrentComponent = null;\n\tif (oldBeforeDiff) oldBeforeDiff(vnode);\n};\n\noptions._root = (vnode, parentDom) => {\n\tif (vnode && parentDom._children && parentDom._children._mask) {\n\t\tvnode._mask = parentDom._children._mask;\n\t}\n\n\tif (oldRoot) oldRoot(vnode, parentDom);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._render = vnode => {\n\tif (oldBeforeRender) oldBeforeRender(vnode);\n\n\tcurrentComponent = vnode._component;\n\tcurrentIndex = 0;\n\n\tconst hooks = currentComponent.__hooks;\n\tif (hooks) {\n\t\tif (previousComponent === currentComponent) {\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentComponent._renderCallbacks = [];\n\t\t\thooks._list.forEach(hookItem => {\n\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t}\n\t\t\t\thookItem._pendingArgs = hookItem._nextValue = undefined;\n\t\t\t});\n\t\t} else {\n\t\t\thooks._pendingEffects.forEach(invokeCleanup);\n\t\t\thooks._pendingEffects.forEach(invokeEffect);\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentIndex = 0;\n\t\t}\n\t}\n\tpreviousComponent = currentComponent;\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.diffed = vnode => {\n\tif (oldAfterDiff) oldAfterDiff(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tif (c.__hooks._pendingEffects.length) afterPaint(afterPaintEffects.push(c));\n\t\tc.__hooks._list.forEach(hookItem => {\n\t\t\tif (hookItem._pendingArgs) {\n\t\t\t\thookItem._args = hookItem._pendingArgs;\n\t\t\t}\n\t\t\thookItem._pendingArgs = undefined;\n\t\t});\n\t}\n\tpreviousComponent = currentComponent = null;\n};\n\n// TODO: Improve typing of commitQueue parameter\n/** @type {(vnode: import('./internal').VNode, commitQueue: any) => void} */\noptions._commit = (vnode, commitQueue) => {\n\tcommitQueue.some(component => {\n\t\ttry {\n\t\t\tcomponent._renderCallbacks.forEach(invokeCleanup);\n\t\t\tcomponent._renderCallbacks = component._renderCallbacks.filter(cb =>\n\t\t\t\tcb._value ? invokeEffect(cb) : true\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tcommitQueue.some(c => {\n\t\t\t\tif (c._renderCallbacks) c._renderCallbacks = [];\n\t\t\t});\n\t\t\tcommitQueue = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t});\n\n\tif (oldCommit) oldCommit(vnode, commitQueue);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.unmount = vnode => {\n\tif (oldBeforeUnmount) oldBeforeUnmount(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tlet hasErrored;\n\t\tc.__hooks._list.forEach(s => {\n\t\t\ttry {\n\t\t\t\tinvokeCleanup(s);\n\t\t\t} catch (e) {\n\t\t\t\thasErrored = e;\n\t\t\t}\n\t\t});\n\t\tc.__hooks = undefined;\n\t\tif (hasErrored) options._catchError(hasErrored, c._vnode);\n\t}\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {any}\n */\nfunction getHookState(index, type) {\n\tif (options._hook) {\n\t\toptions._hook(currentComponent, index, currentHook || type);\n\t}\n\tcurrentHook = 0;\n\n\t// Largely inspired by:\n\t// * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n\t// * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n\t// Other implementations to look at:\n\t// * https://codesandbox.io/s/mnox05qp8\n\tconst hooks =\n\t\tcurrentComponent.__hooks ||\n\t\t(currentComponent.__hooks = {\n\t\t\t_list: [],\n\t\t\t_pendingEffects: []\n\t\t});\n\n\tif (index >= hooks._list.length) {\n\t\thooks._list.push({});\n\t}\n\n\treturn hooks._list[index];\n}\n\n/**\n * @template {unknown} S\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} [initialState]\n * @returns {[S, (state: S) => void]}\n */\nexport function useState(initialState) {\n\tcurrentHook = 1;\n\treturn useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @template {unknown} S\n * @template {unknown} A\n * @param {import('./index').Reducer<S, A>} reducer\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ S, (state: S) => void ]}\n */\nexport function useReducer(reducer, initialState, init) {\n\t/** @type {import('./internal').ReducerHookState} */\n\tconst hookState = getHookState(currentIndex++, 2);\n\thookState._reducer = reducer;\n\tif (!hookState._component) {\n\t\thookState._value = [\n\t\t\t!init ? invokeOrReturn(undefined, initialState) : init(initialState),\n\n\t\t\taction => {\n\t\t\t\tconst currentValue = hookState._nextValue\n\t\t\t\t\t? hookState._nextValue[0]\n\t\t\t\t\t: hookState._value[0];\n\t\t\t\tconst nextValue = hookState._reducer(currentValue, action);\n\n\t\t\t\tif (currentValue !== nextValue) {\n\t\t\t\t\thookState._nextValue = [nextValue, hookState._value[1]];\n\t\t\t\t\thookState._component.setState({});\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\n\t\thookState._component = currentComponent;\n\n\t\tif (!currentComponent._hasScuFromHooks) {\n\t\t\tcurrentComponent._hasScuFromHooks = true;\n\t\t\tlet prevScu = currentComponent.shouldComponentUpdate;\n\t\t\tconst prevCWU = currentComponent.componentWillUpdate;\n\n\t\t\t// If we're dealing with a forced update `shouldComponentUpdate` will\n\t\t\t// not be called. But we use that to update the hook values, so we\n\t\t\t// need to call it.\n\t\t\tcurrentComponent.componentWillUpdate = function (p, s, c) {\n\t\t\t\tif (this._force) {\n\t\t\t\t\tlet tmp = prevScu;\n\t\t\t\t\t// Clear to avoid other sCU hooks from being called\n\t\t\t\t\tprevScu = undefined;\n\t\t\t\t\tupdateHookState(p, s, c);\n\t\t\t\t\tprevScu = tmp;\n\t\t\t\t}\n\n\t\t\t\tif (prevCWU) prevCWU.call(this, p, s, c);\n\t\t\t};\n\n\t\t\t// This SCU has the purpose of bailing out after repeated updates\n\t\t\t// to stateful hooks.\n\t\t\t// we store the next value in _nextValue[0] and keep doing that for all\n\t\t\t// state setters, if we have next states and\n\t\t\t// all next states within a component end up being equal to their original state\n\t\t\t// we are safe to bail out for this specific component.\n\t\t\t/**\n\t\t\t *\n\t\t\t * @type {import('./internal').Component[\"shouldComponentUpdate\"]}\n\t\t\t */\n\t\t\t// @ts-ignore - We don't use TS to downtranspile\n\t\t\t// eslint-disable-next-line no-inner-declarations\n\t\t\tfunction updateHookState(p, s, c) {\n\t\t\t\tif (!hookState._component.__hooks) return true;\n\n\t\t\t\t/** @type {(x: import('./internal').HookState) => x is import('./internal').ReducerHookState} */\n\t\t\t\tconst isStateHook = x => !!x._component;\n\t\t\t\tconst stateHooks =\n\t\t\t\t\thookState._component.__hooks._list.filter(isStateHook);\n\n\t\t\t\tconst allHooksEmpty = stateHooks.every(x => !x._nextValue);\n\t\t\t\t// When we have no updated hooks in the component we invoke the previous SCU or\n\t\t\t\t// traverse the VDOM tree further.\n\t\t\t\tif (allHooksEmpty) {\n\t\t\t\t\treturn prevScu ? prevScu.call(this, p, s, c) : true;\n\t\t\t\t}\n\n\t\t\t\t// We check whether we have components with a nextValue set that\n\t\t\t\t// have values that aren't equal to one another this pushes\n\t\t\t\t// us to update further down the tree\n\t\t\t\tlet shouldUpdate = hookState._component.props !== p;\n\t\t\t\tstateHooks.forEach(hookItem => {\n\t\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\t\tconst currentValue = hookItem._value[0];\n\t\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t\t\thookItem._nextValue = undefined;\n\t\t\t\t\t\tif (currentValue !== hookItem._value[0]) shouldUpdate = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn prevScu\n\t\t\t\t\t? prevScu.call(this, p, s, c) || shouldUpdate\n\t\t\t\t\t: shouldUpdate;\n\t\t\t}\n\n\t\t\tcurrentComponent.shouldComponentUpdate = updateHookState;\n\t\t}\n\t}\n\n\treturn hookState._nextValue || hookState._value;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 3);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent.__hooks._pendingEffects.push(state);\n\t}\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useLayoutEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 4);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent._renderCallbacks.push(state);\n\t}\n}\n\n/** @type {(initialValue: unknown) => unknown} */\nexport function useRef(initialValue) {\n\tcurrentHook = 5;\n\treturn useMemo(() => ({ current: initialValue }), []);\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useImperativeHandle(ref, createHandle, args) {\n\tcurrentHook = 6;\n\tuseLayoutEffect(\n\t\t() => {\n\t\t\tif (typeof ref == 'function') {\n\t\t\t\tconst result = ref(createHandle());\n\t\t\t\treturn () => {\n\t\t\t\t\tref(null);\n\t\t\t\t\tif (result && typeof result == 'function') result();\n\t\t\t\t};\n\t\t\t} else if (ref) {\n\t\t\t\tref.current = createHandle();\n\t\t\t\treturn () => (ref.current = null);\n\t\t\t}\n\t\t},\n\t\targs == null ? args : args.concat(ref)\n\t);\n}\n\n/**\n * @template {unknown} T\n * @param {() => T} factory\n * @param {unknown[]} args\n * @returns {T}\n */\nexport function useMemo(factory, args) {\n\t/** @type {import('./internal').MemoHookState<T>} */\n\tconst state = getHookState(currentIndex++, 7);\n\tif (argsChanged(state._args, args)) {\n\t\tstate._value = factory();\n\t\tstate._args = args;\n\t\tstate._factory = factory;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * @param {() => void} callback\n * @param {unknown[]} args\n * @returns {() => void}\n */\nexport function useCallback(callback, args) {\n\tcurrentHook = 8;\n\treturn useMemo(() => callback, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nexport function useContext(context) {\n\tconst provider = currentComponent.context[context._id];\n\t// We could skip this call here, but than we'd not call\n\t// `options._hook`. We need to do that in order to make\n\t// the devtools aware of this hook.\n\t/** @type {import('./internal').ContextHookState} */\n\tconst state = getHookState(currentIndex++, 9);\n\t// The devtools needs access to the context object to\n\t// be able to pull of the default value when no provider\n\t// is present in the tree.\n\tstate._context = context;\n\tif (!provider) return context._defaultValue;\n\t// This is probably not safe to convert to \"!\"\n\tif (state._value == null) {\n\t\tstate._value = true;\n\t\tprovider.sub(currentComponent);\n\t}\n\treturn provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nexport function useDebugValue(value, formatter) {\n\tif (options.useDebugValue) {\n\t\toptions.useDebugValue(\n\t\t\tformatter ? formatter(value) : /** @type {any}*/ (value)\n\t\t);\n\t}\n}\n\n/**\n * @param {(error: unknown, errorInfo: import('preact').ErrorInfo) => void} cb\n * @returns {[unknown, () => void]}\n */\nexport function useErrorBoundary(cb) {\n\t/** @type {import('./internal').ErrorBoundaryHookState} */\n\tconst state = getHookState(currentIndex++, 10);\n\tconst errState = useState();\n\tstate._value = cb;\n\tif (!currentComponent.componentDidCatch) {\n\t\tcurrentComponent.componentDidCatch = (err, errorInfo) => {\n\t\t\tif (state._value) state._value(err, errorInfo);\n\t\t\terrState[1](err);\n\t\t};\n\t}\n\treturn [\n\t\terrState[0],\n\t\t() => {\n\t\t\terrState[1](undefined);\n\t\t}\n\t];\n}\n\n/** @type {() => string} */\nexport function useId() {\n\t/** @type {import('./internal').IdHookState} */\n\tconst state = getHookState(currentIndex++, 11);\n\tif (!state._value) {\n\t\t// Grab either the root node or the nearest async boundary node.\n\t\t/** @type {import('./internal').VNode} */\n\t\tlet root = currentComponent._vnode;\n\t\twhile (root !== null && !root._mask && root._parent !== null) {\n\t\t\troot = root._parent;\n\t\t}\n\n\t\tlet mask = root._mask || (root._mask = [0, 0]);\n\t\tstate._value = 'P' + mask[0] + '-' + mask[1]++;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n\tlet component;\n\twhile ((component = afterPaintEffects.shift())) {\n\t\tif (!component._parentDom || !component.__hooks) continue;\n\t\ttry {\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeEffect);\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t} catch (e) {\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t}\n}\n\nlet HAS_RAF = typeof requestAnimationFrame == 'function';\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tif (HAS_RAF) cancelAnimationFrame(raf);\n\t\tsetTimeout(callback);\n\t};\n\tconst timeout = setTimeout(done, RAF_TIMEOUT);\n\n\tlet raf;\n\tif (HAS_RAF) {\n\t\traf = requestAnimationFrame(done);\n\t}\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n * @returns {void}\n */\nfunction afterPaint(newQueueLength) {\n\tif (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n\t\tprevRaf = options.requestAnimationFrame;\n\t\t(prevRaf || afterNextFrame)(flushAfterPaintEffects);\n\t}\n}\n\n/**\n * @param {import('./internal').HookState} hook\n * @returns {void}\n */\nfunction invokeCleanup(hook) {\n\t// A hook cleanup can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\tlet cleanup = hook._cleanup;\n\tif (typeof cleanup == 'function') {\n\t\thook._cleanup = undefined;\n\t\tcleanup();\n\t}\n\n\tcurrentComponent = comp;\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n * @returns {void}\n */\nfunction invokeEffect(hook) {\n\t// A hook call can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\thook._cleanup = hook._value();\n\tcurrentComponent = comp;\n}\n\n/**\n * @param {unknown[]} oldArgs\n * @param {unknown[]} newArgs\n * @returns {boolean}\n */\nfunction argsChanged(oldArgs, newArgs) {\n\treturn (\n\t\t!oldArgs ||\n\t\toldArgs.length !== newArgs.length ||\n\t\tnewArgs.some((arg, index) => arg !== oldArgs[index])\n\t);\n}\n\n/**\n * @template Arg\n * @param {Arg} arg\n * @param {(arg: Arg) => any} f\n * @returns {any}\n */\nfunction invokeOrReturn(arg, f) {\n\treturn typeof f == 'function' ? f(arg) : f;\n}\n", "/**\n * Color utility functions using ICtCp and CIEDE2000 perceptual color algorithms\n */\n\nexport interface RGB {\n  r: number;\n  g: number;\n  b: number;\n}\n\nexport interface Lab {\n  L: number;\n  a: number;\n  b: number;\n}\n\nexport interface ICtCp {\n  I: number;\n  Ct: number;\n  Cp: number;\n}\n\n/**\n * Convert sRGB (0-255) to linear RGB (0-1)\n */\nfunction srgbToLinear(c: number): number {\n  const s = c / 255;\n  return s <= 0.04045 ? s / 12.92 : Math.pow((s + 0.055) / 1.055, 2.4);\n}\n\n/**\n * Convert RGB to XYZ (D65 illuminant)\n */\nfunction rgbToXyz(rgb: RGB): { X: number; Y: number; Z: number } {\n  const r = srgbToLinear(rgb.r);\n  const g = srgbToLinear(rgb.g);\n  const b = srgbToLinear(rgb.b);\n\n  return {\n    X: 0.4124564 * r + 0.3575761 * g + 0.1804375 * b,\n    Y: 0.2126729 * r + 0.7151522 * g + 0.0721750 * b,\n    Z: 0.0193339 * r + 0.1191920 * g + 0.9503041 * b\n  };\n}\n\n/**\n * Convert XYZ to Lab (D65 illuminant)\n */\nfunction xyzToLab(xyz: { X: number; Y: number; Z: number }): Lab {\n  // D65 reference white\n  const Xn = 0.95047;\n  const Yn = 1.0;\n  const Zn = 1.08883;\n\n  const f = (t: number): number => {\n    const delta = 6 / 29;\n    return t > delta ** 3 ? Math.cbrt(t) : t / (3 * delta ** 2) + 4 / 29;\n  };\n\n  const fx = f(xyz.X / Xn);\n  const fy = f(xyz.Y / Yn);\n  const fz = f(xyz.Z / Zn);\n\n  return {\n    L: 116 * fy - 16,\n    a: 500 * (fx - fy),\n    b: 200 * (fy - fz)\n  };\n}\n\n/**\n * Convert RGB to Lab\n */\nexport function rgbToLab(rgb: RGB): Lab {\n  return xyzToLab(rgbToXyz(rgb));\n}\n\n/**\n * CIEDE2000 color difference formula\n * Returns a perceptual color distance value\n */\nexport function ciede2000(lab1: Lab, lab2: Lab): number {\n  const { L: L1, a: a1, b: b1 } = lab1;\n  const { L: L2, a: a2, b: b2 } = lab2;\n\n  const C1 = Math.sqrt(a1 * a1 + b1 * b1);\n  const C2 = Math.sqrt(a2 * a2 + b2 * b2);\n  const Cab = (C1 + C2) / 2;\n\n  const G = 0.5 * (1 - Math.sqrt(Math.pow(Cab, 7) / (Math.pow(Cab, 7) + Math.pow(25, 7))));\n  const a1p = a1 * (1 + G);\n  const a2p = a2 * (1 + G);\n\n  const C1p = Math.sqrt(a1p * a1p + b1 * b1);\n  const C2p = Math.sqrt(a2p * a2p + b2 * b2);\n\n  const h1p = Math.atan2(b1, a1p) * 180 / Math.PI + (b1 < 0 ? 360 : 0);\n  const h2p = Math.atan2(b2, a2p) * 180 / Math.PI + (b2 < 0 ? 360 : 0);\n\n  const dLp = L2 - L1;\n  const dCp = C2p - C1p;\n\n  let dhp: number;\n  if (C1p * C2p === 0) {\n    dhp = 0;\n  } else if (Math.abs(h2p - h1p) <= 180) {\n    dhp = h2p - h1p;\n  } else if (h2p - h1p > 180) {\n    dhp = h2p - h1p - 360;\n  } else {\n    dhp = h2p - h1p + 360;\n  }\n\n  const dHp = 2 * Math.sqrt(C1p * C2p) * Math.sin(dhp * Math.PI / 360);\n\n  const Lp = (L1 + L2) / 2;\n  const Cp = (C1p + C2p) / 2;\n\n  let Hp: number;\n  if (C1p * C2p === 0) {\n    Hp = h1p + h2p;\n  } else if (Math.abs(h1p - h2p) <= 180) {\n    Hp = (h1p + h2p) / 2;\n  } else if (h1p + h2p < 360) {\n    Hp = (h1p + h2p + 360) / 2;\n  } else {\n    Hp = (h1p + h2p - 360) / 2;\n  }\n\n  const T = 1 \n    - 0.17 * Math.cos((Hp - 30) * Math.PI / 180) \n    + 0.24 * Math.cos(2 * Hp * Math.PI / 180) \n    + 0.32 * Math.cos((3 * Hp + 6) * Math.PI / 180) \n    - 0.20 * Math.cos((4 * Hp - 63) * Math.PI / 180);\n\n  const dTheta = 30 * Math.exp(-Math.pow((Hp - 275) / 25, 2));\n  const Rc = 2 * Math.sqrt(Math.pow(Cp, 7) / (Math.pow(Cp, 7) + Math.pow(25, 7)));\n  const Sl = 1 + (0.015 * Math.pow(Lp - 50, 2)) / Math.sqrt(20 + Math.pow(Lp - 50, 2));\n  const Sc = 1 + 0.045 * Cp;\n  const Sh = 1 + 0.015 * Cp * T;\n  const Rt = -Math.sin(2 * dTheta * Math.PI / 180) * Rc;\n\n  const kL = 1, kC = 1, kH = 1;\n\n  const deltaE = Math.sqrt(\n    Math.pow(dLp / (kL * Sl), 2) +\n    Math.pow(dCp / (kC * Sc), 2) +\n    Math.pow(dHp / (kH * Sh), 2) +\n    Rt * (dCp / (kC * Sc)) * (dHp / (kH * Sh))\n  );\n\n  return deltaE;\n}\n\n/**\n * PQ transfer function (used in ICtCp)\n */\nfunction pq(x: number): number {\n  const m1 = 0.1593017578125;\n  const m2 = 78.84375;\n  const c1 = 0.8359375;\n  const c2 = 18.8515625;\n  const c3 = 18.6875;\n\n  const xm1 = Math.pow(Math.max(0, x), m1);\n  return Math.pow((c1 + c2 * xm1) / (1 + c3 * xm1), m2);\n}\n\n/**\n * Convert RGB to ICtCp\n */\nexport function rgbToICtCp(rgb: RGB): ICtCp {\n  // Convert to linear RGB (0-1)\n  const r = srgbToLinear(rgb.r);\n  const g = srgbToLinear(rgb.g);\n  const b = srgbToLinear(rgb.b);\n\n  // RGB to LMS\n  const L = 0.412109375 * r + 0.523925781 * g + 0.063964844 * b;\n  const M = 0.166748047 * r + 0.720458984 * g + 0.112792969 * b;\n  const S = 0.024047852 * r + 0.075439453 * g + 0.900512695 * b;\n\n  // Apply PQ transfer function\n  const Lp = pq(L);\n  const Mp = pq(M);\n  const Sp = pq(S);\n\n  // LMS to ICtCp\n  const I = 0.5 * Lp + 0.5 * Mp;\n  const Ct = 1.613769531 * Lp - 3.323486328 * Mp + 1.709716797 * Sp;\n  const Cp = 4.378173828 * Lp - 4.245605469 * Mp - 0.132568359 * Sp;\n\n  return { I, Ct, Cp };\n}\n\n/**\n * ICtCp color difference\n */\nexport function ictcpDistance(ictcp1: ICtCp, ictcp2: ICtCp): number {\n  const dI = ictcp1.I - ictcp2.I;\n  const dCt = ictcp1.Ct - ictcp2.Ct;\n  const dCp = ictcp1.Cp - ictcp2.Cp;\n  \n  // Weighted euclidean distance (weights from Rec. ITU-R BT.2124)\n  return Math.sqrt(dI * dI + dCt * dCt + dCp * dCp);\n}\n\n/**\n * Combined color distance using both CIEDE2000 and ICtCp\n * Returns a normalized value where lower = more similar\n */\nexport function colorDistance(rgb1: RGB, rgb2: RGB): number {\n  const lab1 = rgbToLab(rgb1);\n  const lab2 = rgbToLab(rgb2);\n  const ciede = ciede2000(lab1, lab2);\n\n  const ictcp1 = rgbToICtCp(rgb1);\n  const ictcp2 = rgbToICtCp(rgb2);\n  const ictcp = ictcpDistance(ictcp1, ictcp2);\n\n  // Combine both metrics (CIEDE2000 is typically 0-100, ICtCp is smaller)\n  // Weight them to get a reasonable combined metric\n  return (ciede + ictcp * 50) / 2;\n}\n\n/**\n * Check if two colors are \"the same\" given a threshold\n */\nexport function colorsMatch(rgb1: RGB, rgb2: RGB, threshold: number): boolean {\n  return colorDistance(rgb1, rgb2) < threshold;\n}\n\n/**\n * Get the median color from an array of RGB values\n */\nexport function medianColor(colors: RGB[]): RGB {\n  if (colors.length === 0) {\n    return { r: 0, g: 0, b: 0 };\n  }\n\n  const sortedR = [...colors].sort((a, b) => a.r - b.r);\n  const sortedG = [...colors].sort((a, b) => a.g - b.g);\n  const sortedB = [...colors].sort((a, b) => a.b - b.b);\n\n  const mid = Math.floor(colors.length / 2);\n\n  return {\n    r: sortedR[mid].r,\n    g: sortedG[mid].g,\n    b: sortedB[mid].b\n  };\n}\n\n/**\n * K-means clustering for color reduction\n */\nexport function kMeansCluster(colors: RGB[], k: number, maxIterations = 50): RGB[] {\n  if (colors.length <= k) {\n    return [...colors];\n  }\n\n  // Initialize centroids using k-means++ initialization\n  const centroids: RGB[] = [];\n  centroids.push(colors[Math.floor(Math.random() * colors.length)]);\n\n  for (let i = 1; i < k; i++) {\n    const distances = colors.map(color => {\n      let minDist = Infinity;\n      for (const centroid of centroids) {\n        const dist = colorDistance(color, centroid);\n        if (dist < minDist) minDist = dist;\n      }\n      return minDist * minDist;\n    });\n\n    const totalDist = distances.reduce((a, b) => a + b, 0);\n    let random = Math.random() * totalDist;\n    \n    for (let j = 0; j < colors.length; j++) {\n      random -= distances[j];\n      if (random <= 0) {\n        centroids.push(colors[j]);\n        break;\n      }\n    }\n  }\n\n  // Iterate\n  for (let iter = 0; iter < maxIterations; iter++) {\n    // Assign colors to clusters\n    const clusters: RGB[][] = Array.from({ length: k }, () => []);\n    \n    for (const color of colors) {\n      let minDist = Infinity;\n      let minIdx = 0;\n      for (let i = 0; i < centroids.length; i++) {\n        const dist = colorDistance(color, centroids[i]);\n        if (dist < minDist) {\n          minDist = dist;\n          minIdx = i;\n        }\n      }\n      clusters[minIdx].push(color);\n    }\n\n    // Update centroids\n    let changed = false;\n    for (let i = 0; i < k; i++) {\n      if (clusters[i].length > 0) {\n        const newCentroid = medianColor(clusters[i]);\n        if (newCentroid.r !== centroids[i].r || \n            newCentroid.g !== centroids[i].g || \n            newCentroid.b !== centroids[i].b) {\n          centroids[i] = newCentroid;\n          changed = true;\n        }\n      }\n    }\n\n    if (!changed) break;\n  }\n\n  return centroids;\n}\n\n/**\n * Map a color to the nearest cluster centroid\n */\nexport function mapToCluster(color: RGB, centroids: RGB[]): RGB {\n  let minDist = Infinity;\n  let nearest = centroids[0];\n\n  for (const centroid of centroids) {\n    const dist = colorDistance(color, centroid);\n    if (dist < minDist) {\n      minDist = dist;\n      nearest = centroid;\n    }\n  }\n\n  return nearest;\n}\n", "/**\n * Flood fill algorithm with color thresholding\n */\n\nimport { RGB, colorsMatch, medianColor } from './colors.js';\n\nexport interface Point {\n  x: number;\n  y: number;\n}\n\nexport interface FloodFillResult {\n  pixels: Set<string>;\n  bounds: { minX: number; minY: number; maxX: number; maxY: number };\n  color: RGB;\n}\n\n/**\n * Get pixel from ImageData\n */\nexport function getPixel(imageData: ImageData, x: number, y: number): RGB {\n  const idx = (y * imageData.width + x) * 4;\n  return {\n    r: imageData.data[idx],\n    g: imageData.data[idx + 1],\n    b: imageData.data[idx + 2]\n  };\n}\n\n/**\n * Get alpha from ImageData\n */\nexport function getAlpha(imageData: ImageData, x: number, y: number): number {\n  const idx = (y * imageData.width + x) * 4;\n  return imageData.data[idx + 3];\n}\n\n/**\n * Perform flood fill from a starting point with given color threshold\n */\nexport function floodFill(\n  imageData: ImageData,\n  startX: number,\n  startY: number,\n  threshold: number\n): FloodFillResult {\n  const width = imageData.width;\n  const height = imageData.height;\n  const startColor = getPixel(imageData, startX, startY);\n  \n  const visited = new Set<string>();\n  const pixels = new Set<string>();\n  const stack: Point[] = [{ x: startX, y: startY }];\n  \n  let minX = startX, maxX = startX, minY = startY, maxY = startY;\n  const colorSamples: RGB[] = [];\n\n  while (stack.length > 0) {\n    const { x, y } = stack.pop()!;\n    const key = `${x},${y}`;\n    \n    if (visited.has(key)) continue;\n    visited.add(key);\n    \n    if (x < 0 || x >= width || y < 0 || y >= height) continue;\n    \n    const pixel = getPixel(imageData, x, y);\n    if (!colorsMatch(pixel, startColor, threshold)) continue;\n    \n    pixels.add(key);\n    colorSamples.push(pixel);\n    \n    minX = Math.min(minX, x);\n    maxX = Math.max(maxX, x);\n    minY = Math.min(minY, y);\n    maxY = Math.max(maxY, y);\n    \n    // Add neighbors\n    stack.push({ x: x - 1, y });\n    stack.push({ x: x + 1, y });\n    stack.push({ x, y: y - 1 });\n    stack.push({ x, y: y + 1 });\n  }\n\n  return {\n    pixels,\n    bounds: { minX, minY, maxX, maxY },\n    color: medianColor(colorSamples)\n  };\n}\n\n/**\n * Get multiple flood fill candidates with different thresholds\n */\nexport function getFloodFillCandidates(\n  imageData: ImageData,\n  startX: number,\n  startY: number,\n  thresholds: number[] = [5, 10, 15, 25]\n): FloodFillResult[] {\n  return thresholds.map(threshold => \n    floodFill(imageData, startX, startY, threshold)\n  );\n}\n\n/**\n * Find perimeter pixels of the image\n */\nexport function getPerimeterPixels(imageData: ImageData): RGB[] {\n  const width = imageData.width;\n  const height = imageData.height;\n  const perimeter: RGB[] = [];\n\n  // Top and bottom edges\n  for (let x = 0; x < width; x++) {\n    perimeter.push(getPixel(imageData, x, 0));\n    perimeter.push(getPixel(imageData, x, height - 1));\n  }\n\n  // Left and right edges (excluding corners already counted)\n  for (let y = 1; y < height - 1; y++) {\n    perimeter.push(getPixel(imageData, 0, y));\n    perimeter.push(getPixel(imageData, width - 1, y));\n  }\n\n  return perimeter;\n}\n\n/**\n * Find the most common color on the perimeter\n */\nexport function getMostCommonPerimeterColor(imageData: ImageData, bucketSize = 10): RGB {\n  const perimeter = getPerimeterPixels(imageData);\n  const buckets = new Map<string, RGB[]>();\n\n  for (const color of perimeter) {\n    // Bucket colors to find most common\n    const key = `${Math.floor(color.r / bucketSize)},${Math.floor(color.g / bucketSize)},${Math.floor(color.b / bucketSize)}`;\n    if (!buckets.has(key)) {\n      buckets.set(key, []);\n    }\n    buckets.get(key)!.push(color);\n  }\n\n  let maxCount = 0;\n  let maxColors: RGB[] = [];\n  for (const colors of buckets.values()) {\n    if (colors.length > maxCount) {\n      maxCount = colors.length;\n      maxColors = colors;\n    }\n  }\n\n  return medianColor(maxColors);\n}\n\n/**\n * Find all pixels connected to edge with \"same\" color as perimeter\n */\nexport function findTransparentPixels(\n  imageData: ImageData,\n  perimeterColor: RGB,\n  threshold: number\n): Set<string> {\n  const width = imageData.width;\n  const height = imageData.height;\n  const visited = new Set<string>();\n  const transparent = new Set<string>();\n  const stack: Point[] = [];\n\n  // Start from all edge pixels\n  for (let x = 0; x < width; x++) {\n    stack.push({ x, y: 0 });\n    stack.push({ x, y: height - 1 });\n  }\n  for (let y = 0; y < height; y++) {\n    stack.push({ x: 0, y });\n    stack.push({ x: width - 1, y });\n  }\n\n  while (stack.length > 0) {\n    const { x, y } = stack.pop()!;\n    const key = `${x},${y}`;\n    \n    if (visited.has(key)) continue;\n    visited.add(key);\n    \n    if (x < 0 || x >= width || y < 0 || y >= height) continue;\n    \n    const pixel = getPixel(imageData, x, y);\n    if (!colorsMatch(pixel, perimeterColor, threshold)) continue;\n    \n    transparent.add(key);\n    \n    stack.push({ x: x - 1, y });\n    stack.push({ x: x + 1, y });\n    stack.push({ x, y: y - 1 });\n    stack.push({ x, y: y + 1 });\n  }\n\n  return transparent;\n}\n", "/**\n * Region detection and shape analysis\n */\n\nimport { RGB, medianColor } from './colors.js';\nimport { FloodFillResult, getPixel } from './floodFill.js';\n\nexport interface Region {\n  id: string;\n  pixels: Set<string>;\n  bounds: { minX: number; minY: number; maxX: number; maxY: number };\n  color: RGB;\n  gridX: number;\n  gridY: number;\n  gridWidth: number;\n  gridHeight: number;\n  /** \n   * Shape mask: a 2D boolean array [row][col] indicating which cells within the\n   * gridWidth \u00D7 gridHeight rectangle are actually filled. If a cell is false,\n   * it should not contribute to output pixels.\n   * Row-major: shapeMask[y][x] where 0 <= y < gridHeight and 0 <= x < gridWidth.\n   */\n  shapeMask: boolean[][];\n  /**\n   * Cell colors: a 2D array of RGB values for each cell in the shape.\n   * cellColors[y][x] contains the sampled color for that specific cell.\n   * Only valid when shapeMask[y][x] is true.\n   */\n  cellColors: (RGB | null)[][];\n}\n\nexport interface RegionCandidate {\n  gridWidth: number;\n  gridHeight: number;\n  score: number;\n  previewPixels: Array<{ x: number; y: number }>;\n  /** \n   * Shape mask: a 2D boolean array [row][col] indicating which cells are filled.\n   * Row-major: shapeMask[y][x] where 0 <= y < gridHeight and 0 <= x < gridWidth.\n   */\n  shapeMask: boolean[][];\n  /**\n   * Cell colors: a 2D array of RGB values for each filled cell.\n   * cellColors[y][x] contains the sampled color for that cell.\n   */\n  cellColors: (RGB | null)[][];\n}\n\n/**\n * Analyze a flood fill result and determine possible grid shapes\n */\nexport function analyzeRegionShape(result: FloodFillResult, imageData: ImageData): RegionCandidate[] {\n  const { bounds, pixels } = result;\n  const width = bounds.maxX - bounds.minX + 1;\n  const height = bounds.maxY - bounds.minY + 1;\n  const aspectRatio = width / height;\n  const pixelCount = pixels.size;\n  \n  // Calculate fill density\n  const area = width * height;\n  const density = pixelCount / area;\n\n  const candidates: RegionCandidate[] = [];\n\n  // Generate candidate shapes based on aspect ratio\n  // For a roughly square region, candidates are 1x1, 2x2, 3x3, 4x4\n  // For elongated regions, consider the aspect ratio\n  \n  const possibleShapes: Array<[number, number]> = [];\n  \n  if (aspectRatio >= 0.7 && aspectRatio <= 1.4) {\n    // Roughly square\n    possibleShapes.push([1, 1], [2, 2], [3, 3], [4, 4]);\n  } else if (aspectRatio > 1.4) {\n    // Wider than tall\n    const ratio = Math.round(aspectRatio);\n    possibleShapes.push([1, 1]);\n    for (let w = 2; w <= Math.min(8, ratio + 2); w++) {\n      for (let h = 1; h <= Math.min(4, w); h++) {\n        if (Math.abs(w / h - aspectRatio) < 1) {\n          possibleShapes.push([w, h]);\n        }\n      }\n    }\n  } else {\n    // Taller than wide\n    const ratio = Math.round(1 / aspectRatio);\n    possibleShapes.push([1, 1]);\n    for (let h = 2; h <= Math.min(8, ratio + 2); h++) {\n      for (let w = 1; w <= Math.min(4, h); w++) {\n        if (Math.abs(w / h - aspectRatio) < 1) {\n          possibleShapes.push([w, h]);\n        }\n      }\n    }\n  }\n\n  // Score each candidate shape\n  for (const [gw, gh] of possibleShapes) {\n    const expectedAspect = gw / gh;\n    const aspectScore = 1 - Math.abs(aspectRatio - expectedAspect) / Math.max(aspectRatio, expectedAspect);\n    \n    // Check if density is consistent with a solid block\n    const densityScore = density > 0.5 ? 1 : density * 2;\n    \n    // Calculate shape mask and cell colors\n    const { shapeMask, cellColors, filledCellCount } = computeShapeMaskAndColors(result, imageData, gw, gh);\n    \n    // Score based on how well the shape mask matches expectations\n    const expectedFilledCells = gw * gh;\n    const fillRatio = filledCellCount / expectedFilledCells;\n    \n    // Check rectangularity - now we use the shape mask\n    const rectangularityScore = calculateRectangularityWithMask(result, gw, gh, shapeMask);\n    \n    const score = (aspectScore * 0.4 + densityScore * 0.3 + rectangularityScore * 0.3) * fillRatio;\n\n    // Generate preview pixels for this candidate\n    const previewPixels: Array<{ x: number; y: number }> = [];\n    const cellW = width / gw;\n    const cellH = height / gh;\n    for (let gy = 0; gy < gh; gy++) {\n      for (let gx = 0; gx < gw; gx++) {\n        previewPixels.push({\n          x: bounds.minX + Math.floor(cellW * (gx + 0.5)),\n          y: bounds.minY + Math.floor(cellH * (gy + 0.5))\n        });\n      }\n    }\n\n    candidates.push({\n      gridWidth: gw,\n      gridHeight: gh,\n      score,\n      previewPixels,\n      shapeMask,\n      cellColors\n    });\n  }\n\n  // Sort by score descending and take top 4 unique shapes\n  candidates.sort((a, b) => b.score - a.score);\n  const unique: RegionCandidate[] = [];\n  const seen = new Set<string>();\n  for (const c of candidates) {\n    const key = `${c.gridWidth}x${c.gridHeight}`;\n    if (!seen.has(key)) {\n      seen.add(key);\n      unique.push(c);\n      if (unique.length >= 4) break;\n    }\n  }\n\n  return unique;\n}\n\n/**\n * Calculate rectangularity considering the shape mask\n */\nfunction calculateRectangularityWithMask(result: FloodFillResult, gw: number, gh: number, shapeMask: boolean[][]): number {\n  const { bounds, pixels } = result;\n  const width = bounds.maxX - bounds.minX + 1;\n  const height = bounds.maxY - bounds.minY + 1;\n  const cellW = width / gw;\n  const cellH = height / gh;\n  \n  let totalExpectedPixels = 0;\n  let actualFilledPixels = 0;\n\n  for (let gy = 0; gy < gh; gy++) {\n    for (let gx = 0; gx < gw; gx++) {\n      // Only consider cells that are in the shape mask\n      if (!shapeMask[gy][gx]) continue;\n      \n      const cellMinX = Math.floor(bounds.minX + cellW * gx);\n      const cellMaxX = Math.floor(bounds.minX + cellW * (gx + 1));\n      const cellMinY = Math.floor(bounds.minY + cellH * gy);\n      const cellMaxY = Math.floor(bounds.minY + cellH * (gy + 1));\n      \n      let cellPixels = 0;\n      const cellArea = (cellMaxX - cellMinX) * (cellMaxY - cellMinY);\n      \n      for (let y = cellMinY; y < cellMaxY; y++) {\n        for (let x = cellMinX; x < cellMaxX; x++) {\n          if (pixels.has(`${x},${y}`)) {\n            cellPixels++;\n          }\n        }\n      }\n      \n      totalExpectedPixels += cellArea;\n      actualFilledPixels += cellPixels;\n    }\n  }\n\n  if (totalExpectedPixels === 0) return 0;\n  return actualFilledPixels / totalExpectedPixels;\n}\n\n/**\n * Compute shape mask and per-cell colors for a given grid size\n * A cell is considered \"filled\" if more than 50% of its pixels are in the flood fill result\n */\nfunction computeShapeMaskAndColors(\n  result: FloodFillResult,\n  imageData: ImageData,\n  gw: number,\n  gh: number\n): { shapeMask: boolean[][]; cellColors: (RGB | null)[][]; filledCellCount: number } {\n  const { bounds, pixels } = result;\n  const width = bounds.maxX - bounds.minX + 1;\n  const height = bounds.maxY - bounds.minY + 1;\n  const cellW = width / gw;\n  const cellH = height / gh;\n  \n  const shapeMask: boolean[][] = [];\n  const cellColors: (RGB | null)[][] = [];\n  let filledCellCount = 0;\n\n  for (let gy = 0; gy < gh; gy++) {\n    shapeMask[gy] = [];\n    cellColors[gy] = [];\n    \n    for (let gx = 0; gx < gw; gx++) {\n      const cellMinX = Math.floor(bounds.minX + cellW * gx);\n      const cellMaxX = Math.floor(bounds.minX + cellW * (gx + 1));\n      const cellMinY = Math.floor(bounds.minY + cellH * gy);\n      const cellMaxY = Math.floor(bounds.minY + cellH * (gy + 1));\n      \n      let cellPixels = 0;\n      const cellArea = (cellMaxX - cellMinX) * (cellMaxY - cellMinY);\n      const colorSamples: RGB[] = [];\n      \n      for (let y = cellMinY; y < cellMaxY; y++) {\n        for (let x = cellMinX; x < cellMaxX; x++) {\n          if (pixels.has(`${x},${y}`)) {\n            cellPixels++;\n            // Sample the color from the image\n            colorSamples.push(getPixel(imageData, x, y));\n          }\n        }\n      }\n      \n      // Cell is filled if more than 50% of its area has flood-fill pixels\n      const isFilled = cellPixels > cellArea * 0.5;\n      shapeMask[gy][gx] = isFilled;\n      \n      if (isFilled) {\n        filledCellCount++;\n        // Use median color of the filled pixels in this cell\n        cellColors[gy][gx] = colorSamples.length > 0 ? medianColor(colorSamples) : null;\n      } else {\n        cellColors[gy][gx] = null;\n      }\n    }\n  }\n\n  return { shapeMask, cellColors, filledCellCount };\n}\n\n/**\n * Create a region from a flood fill result and chosen candidate\n */\nexport function createRegion(\n  result: FloodFillResult,\n  candidate: RegionCandidate\n): Region {\n  return {\n    id: crypto.randomUUID(),\n    pixels: result.pixels,\n    bounds: result.bounds,\n    color: result.color,\n    gridX: 0, // Will be set by grid inference\n    gridY: 0,\n    gridWidth: candidate.gridWidth,\n    gridHeight: candidate.gridHeight,\n    shapeMask: candidate.shapeMask,\n    cellColors: candidate.cellColors\n  };\n}\n", "/**\n * Grid inference from known regions\n */\n\nimport { Region } from './regions.js';\nimport { RGB } from './colors.js';\nimport { getPixel } from './floodFill.js';\n\nexport interface Grid {\n  // Pixel pitch (size of one output pixel in input image coordinates)\n  pitchX: number;\n  pitchY: number;\n  // Offset (position of first pixel center in input image)\n  offsetX: number;\n  offsetY: number;\n  // Output dimensions\n  width: number;\n  height: number;\n}\n\nexport interface GridInferenceResult {\n  grid: Grid | null;\n  confidence: number;\n}\n\n/**\n * Infer grid parameters from known regions\n */\nexport function inferGrid(\n  regions: Region[],\n  imageWidth: number,\n  imageHeight: number\n): GridInferenceResult {\n  if (regions.length < 4) {\n    return { grid: null, confidence: 0 };\n  }\n\n  // Collect all region centers and their presumed grid positions\n  const samples: Array<{\n    centerX: number;\n    centerY: number;\n    gridWidth: number;\n    gridHeight: number;\n  }> = [];\n\n  for (const region of regions) {\n    const centerX = (region.bounds.minX + region.bounds.maxX) / 2;\n    const centerY = (region.bounds.minY + region.bounds.maxY) / 2;\n    const pixelWidth = region.bounds.maxX - region.bounds.minX + 1;\n    const pixelHeight = region.bounds.maxY - region.bounds.minY + 1;\n    \n    samples.push({\n      centerX,\n      centerY,\n      gridWidth: region.gridWidth,\n      gridHeight: region.gridHeight\n    });\n\n    // Estimate pitch from region size\n    const estimatedPitchX = pixelWidth / region.gridWidth;\n    const estimatedPitchY = pixelHeight / region.gridHeight;\n    \n    // Store pitch estimate\n    samples[samples.length - 1] = {\n      ...samples[samples.length - 1],\n      estimatedPitchX,\n      estimatedPitchY\n    } as typeof samples[0] & { estimatedPitchX: number; estimatedPitchY: number };\n  }\n\n  // Calculate median pitch from all regions\n  const pitchSamples = samples.map(s => {\n    const es = s as typeof s & { estimatedPitchX: number; estimatedPitchY: number };\n    return { x: es.estimatedPitchX, y: es.estimatedPitchY };\n  }).filter(p => p.x && p.y);\n\n  if (pitchSamples.length === 0) {\n    return { grid: null, confidence: 0 };\n  }\n\n  pitchSamples.sort((a, b) => a.x - b.x);\n  const medianPitchX = pitchSamples[Math.floor(pitchSamples.length / 2)].x;\n  \n  pitchSamples.sort((a, b) => a.y - b.y);\n  const medianPitchY = pitchSamples[Math.floor(pitchSamples.length / 2)].y;\n\n  // Find the offset by analyzing where pixel centers should be\n  // Calculate what grid position would put a pixel at this center\n  // offset = center - gridPos * pitch\n  // We need to find offset such that floor((center - offset) / pitch) gives integer grid positions\n  \n  const offsetXCandidates: number[] = [];\n  const offsetYCandidates: number[] = [];\n  \n  for (const region of regions) {\n    const centerX = (region.bounds.minX + region.bounds.maxX) / 2;\n    const centerY = (region.bounds.minY + region.bounds.maxY) / 2;\n    \n    // Offset should position the center within a pixel cell\n    const offX = centerX % medianPitchX;\n    const offY = centerY % medianPitchY;\n    \n    offsetXCandidates.push(offX);\n    offsetYCandidates.push(offY);\n  }\n\n  // Use median offset\n  offsetXCandidates.sort((a, b) => a - b);\n  offsetYCandidates.sort((a, b) => a - b);\n  const offsetX = offsetXCandidates[Math.floor(offsetXCandidates.length / 2)];\n  const offsetY = offsetYCandidates[Math.floor(offsetYCandidates.length / 2)];\n\n  // Calculate output dimensions\n  const width = Math.ceil(imageWidth / medianPitchX);\n  const height = Math.ceil(imageHeight / medianPitchY);\n\n  // Calculate confidence based on how well regions align to the grid\n  let alignmentError = 0;\n  for (const region of regions) {\n    const centerX = (region.bounds.minX + region.bounds.maxX) / 2;\n    const centerY = (region.bounds.minY + region.bounds.maxY) / 2;\n    \n    const gridX = Math.round((centerX - offsetX) / medianPitchX);\n    const gridY = Math.round((centerY - offsetY) / medianPitchY);\n    \n    const expectedX = offsetX + gridX * medianPitchX;\n    const expectedY = offsetY + gridY * medianPitchY;\n    \n    alignmentError += Math.sqrt(\n      Math.pow(centerX - expectedX, 2) + Math.pow(centerY - expectedY, 2)\n    );\n  }\n  \n  const avgError = alignmentError / regions.length;\n  const maxAllowedError = Math.max(medianPitchX, medianPitchY) * 0.3;\n  const confidence = Math.max(0, 1 - avgError / maxAllowedError);\n\n  return {\n    grid: {\n      pitchX: medianPitchX,\n      pitchY: medianPitchY,\n      offsetX,\n      offsetY,\n      width,\n      height\n    },\n    confidence\n  };\n}\n\n/**\n * Assign grid positions to regions based on inferred grid\n */\nexport function assignGridPositions(regions: Region[], grid: Grid): Region[] {\n  return regions.map(region => {\n    const centerX = (region.bounds.minX + region.bounds.maxX) / 2;\n    const centerY = (region.bounds.minY + region.bounds.maxY) / 2;\n    \n    const gridX = Math.round((centerX - grid.offsetX) / grid.pitchX);\n    const gridY = Math.round((centerY - grid.offsetY) / grid.pitchY);\n\n    return {\n      ...region,\n      gridX,\n      gridY\n    };\n  });\n}\n\n/**\n * Sample the color at a grid position using center-weighted average\n */\nexport function sampleGridPixel(\n  imageData: ImageData,\n  grid: Grid,\n  gridX: number,\n  gridY: number\n): RGB {\n  const centerX = grid.offsetX + gridX * grid.pitchX;\n  const centerY = grid.offsetY + gridY * grid.pitchY;\n  \n  const halfPitchX = grid.pitchX / 2;\n  const halfPitchY = grid.pitchY / 2;\n  \n  const colors: Array<{ color: RGB; weight: number }> = [];\n  \n  // Sample points within the pixel area with center weighting\n  const sampleRadius = Math.min(grid.pitchX, grid.pitchY) * 0.4;\n  \n  for (let dy = -halfPitchY; dy <= halfPitchY; dy += grid.pitchY / 4) {\n    for (let dx = -halfPitchX; dx <= halfPitchX; dx += grid.pitchX / 4) {\n      const x = Math.round(centerX + dx);\n      const y = Math.round(centerY + dy);\n      \n      if (x < 0 || x >= imageData.width || y < 0 || y >= imageData.height) {\n        continue;\n      }\n      \n      const dist = Math.sqrt(dx * dx + dy * dy);\n      const weight = Math.max(0, 1 - dist / sampleRadius);\n      \n      colors.push({\n        color: getPixel(imageData, x, y),\n        weight\n      });\n    }\n  }\n  \n  if (colors.length === 0) {\n    return { r: 0, g: 0, b: 0 };\n  }\n  \n  // Weighted average\n  let totalWeight = 0;\n  let r = 0, g = 0, b = 0;\n  \n  for (const { color, weight } of colors) {\n    totalWeight += weight;\n    r += color.r * weight;\n    g += color.g * weight;\n    b += color.b * weight;\n  }\n  \n  return {\n    r: Math.round(r / totalWeight),\n    g: Math.round(g / totalWeight),\n    b: Math.round(b / totalWeight)\n  };\n}\n\n/**\n * Generate output image from grid and known regions\n */\nexport function generateOutput(\n  imageData: ImageData,\n  grid: Grid,\n  regions: Region[],\n  transparentPixels: Set<string> | null,\n  colorCentroids: RGB[] | null\n): ImageData {\n  const output = new ImageData(grid.width, grid.height);\n  \n  // Create a map of known region colors, respecting shape masks\n  const regionMap = new Map<string, RGB>();\n  for (const region of regions) {\n    for (let dy = 0; dy < region.gridHeight; dy++) {\n      for (let dx = 0; dx < region.gridWidth; dx++) {\n        // Only include cells that are filled according to the shape mask\n        if (region.shapeMask && region.shapeMask[dy] && !region.shapeMask[dy][dx]) {\n          continue;\n        }\n        const key = `${region.gridX + dx},${region.gridY + dy}`;\n        // Use per-cell color if available, otherwise fall back to region color\n        const cellColor = region.cellColors?.[dy]?.[dx] ?? region.color;\n        regionMap.set(key, cellColor);\n      }\n    }\n  }\n  \n  for (let y = 0; y < grid.height; y++) {\n    for (let x = 0; x < grid.width; x++) {\n      const key = `${x},${y}`;\n      let color: RGB;\n      \n      if (regionMap.has(key)) {\n        color = regionMap.get(key)!;\n      } else {\n        color = sampleGridPixel(imageData, grid, x, y);\n      }\n      \n      // Apply color clustering if enabled\n      if (colorCentroids) {\n        color = findNearestCentroid(color, colorCentroids);\n      }\n      \n      const idx = (y * grid.width + x) * 4;\n      output.data[idx] = color.r;\n      output.data[idx + 1] = color.g;\n      output.data[idx + 2] = color.b;\n      \n      // Check transparency\n      const centerX = Math.round(grid.offsetX + x * grid.pitchX);\n      const centerY = Math.round(grid.offsetY + y * grid.pitchY);\n      const isTransparent = transparentPixels?.has(`${centerX},${centerY}`);\n      output.data[idx + 3] = isTransparent ? 0 : 255;\n    }\n  }\n  \n  return output;\n}\n\nfunction findNearestCentroid(color: RGB, centroids: RGB[]): RGB {\n  let minDist = Infinity;\n  let nearest = color;\n  \n  for (const c of centroids) {\n    const dist = Math.sqrt(\n      Math.pow(color.r - c.r, 2) +\n      Math.pow(color.g - c.g, 2) +\n      Math.pow(color.b - c.b, 2)\n    );\n    if (dist < minDist) {\n      minDist = dist;\n      nearest = c;\n    }\n  }\n  \n  return nearest;\n}\n", "/**\n * State management and localStorage persistence\n */\n\nimport { Region } from './regions.js';\n\nexport interface AppState {\n  imageDataUrl: string | null;\n  regions: Region[];\n  inferTransparency: boolean;\n  transparencyThreshold: number;\n  maxColors: number | null;\n  version: string;\n}\n\nconst STORAGE_KEY = 'pix-app-state';\nconst STATE_VERSION = '2';\n\nexport function getDefaultState(): AppState {\n  return {\n    imageDataUrl: null,\n    regions: [],\n    inferTransparency: false,\n    transparencyThreshold: 10,\n    maxColors: null,\n    version: STATE_VERSION\n  };\n}\n\nexport function saveState(state: AppState): void {\n  try {\n    const serialized: SerializedState = {\n      ...state,\n      regions: state.regions.map(r => ({\n        ...r,\n        pixels: Array.from(r.pixels)\n      }))\n    };\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(serialized));\n  } catch (e) {\n    console.error('Failed to save state:', e);\n  }\n}\n\ninterface SerializedRegion extends Omit<Region, 'pixels'> {\n  pixels: string[];\n}\n\ninterface SerializedState extends Omit<AppState, 'regions'> {\n  regions: SerializedRegion[];\n}\n\nexport function loadState(): AppState {\n  try {\n    const stored = localStorage.getItem(STORAGE_KEY);\n    if (!stored) return getDefaultState();\n    \n    const parsed = JSON.parse(stored) as SerializedState;\n    \n    // Version check\n    if (parsed.version !== STATE_VERSION) {\n      return getDefaultState();\n    }\n    \n    return {\n      ...parsed,\n      regions: parsed.regions.map(r => ({\n        ...r,\n        pixels: new Set(r.pixels)\n      }))\n    };\n  } catch (e) {\n    console.error('Failed to load state:', e);\n    return getDefaultState();\n  }\n}\n\nexport function clearState(): void {\n  localStorage.removeItem(STORAGE_KEY);\n}\n", "const ENCODED_ENTITIES = /[\"&<]/;\n\n/** @param {string} str */\nexport function encodeEntities(str) {\n\t// Skip all work for strings with no entities needing encoding:\n\tif (str.length === 0 || ENCODED_ENTITIES.test(str) === false) return str;\n\n\tlet last = 0,\n\t\ti = 0,\n\t\tout = '',\n\t\tch = '';\n\n\t// Seek forward in str until the next entity char:\n\tfor (; i < str.length; i++) {\n\t\tswitch (str.charCodeAt(i)) {\n\t\t\tcase 34:\n\t\t\t\tch = '&quot;';\n\t\t\t\tbreak;\n\t\t\tcase 38:\n\t\t\t\tch = '&amp;';\n\t\t\t\tbreak;\n\t\t\tcase 60:\n\t\t\t\tch = '&lt;';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t}\n\t\t// Append skipped/buffered characters and the encoded entity:\n\t\tif (i !== last) out += str.slice(last, i);\n\t\tout += ch;\n\t\t// Start the next seek/buffer after the entity's offset:\n\t\tlast = i + 1;\n\t}\n\tif (i !== last) out += str.slice(last, i);\n\treturn out;\n}\n", "/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Indicates that this node needs to be inserted while patching children */\nexport const INSERT_VNODE = 1 << 2;\n/** Indicates a VNode has been matched with another VNode in the diff */\nexport const MATCHED = 1 << 1;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(MODE_HYDRATE | MODE_SUSPENDED);\n\nexport const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\nexport const XHTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\nexport const MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n\nexport const NULL = null;\nexport const UNDEFINED = undefined;\nexport const EMPTY_OBJ = /** @type {any} */ ({});\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL =\n\t/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n", "import { options, Fragment } from 'preact';\nimport { encodeEntities } from './utils';\nimport { IS_NON_DIMENSIONAL } from '../../src/constants';\n\nlet vnodeId = 0;\n\nconst isArray = Array.isArray;\n\n/**\n * @fileoverview\n * This file exports various methods that implement Babel's \"automatic\" JSX runtime API:\n * - jsx(type, props, key)\n * - jsxs(type, props, key)\n * - jsxDEV(type, props, key, __source, __self)\n *\n * The implementation of createVNode here is optimized for performance.\n * Benchmarks: https://esbench.com/bench/5f6b54a0b4632100a7dcd2b3\n */\n\n/**\n * JSX.Element factory used by Babel's {runtime:\"automatic\"} JSX transform\n * @param {VNode['type']} type\n * @param {VNode['props']} props\n * @param {VNode['key']} [key]\n * @param {unknown} [isStaticChildren]\n * @param {unknown} [__source]\n * @param {unknown} [__self]\n */\nfunction createVNode(type, props, key, isStaticChildren, __source, __self) {\n\tif (!props) props = {};\n\t// We'll want to preserve `ref` in props to get rid of the need for\n\t// forwardRef components in the future, but that should happen via\n\t// a separate PR.\n\tlet normalizedProps = props,\n\t\tref,\n\t\ti;\n\n\tif ('ref' in normalizedProps) {\n\t\tnormalizedProps = {};\n\t\tfor (i in props) {\n\t\t\tif (i == 'ref') {\n\t\t\t\tref = props[i];\n\t\t\t} else {\n\t\t\t\tnormalizedProps[i] = props[i];\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @type {VNode & { __source: any; __self: any }} */\n\tconst vnode = {\n\t\ttype,\n\t\tprops: normalizedProps,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t_component: null,\n\t\tconstructor: undefined,\n\t\t_original: --vnodeId,\n\t\t_index: -1,\n\t\t_flags: 0,\n\t\t__source,\n\t\t__self\n\t};\n\n\t// If a Component VNode, check for and apply defaultProps.\n\t// Note: `type` is often a String, and can be `undefined` in development.\n\tif (typeof type === 'function' && (ref = type.defaultProps)) {\n\t\tfor (i in ref)\n\t\t\tif (normalizedProps[i] === undefined) {\n\t\t\t\tnormalizedProps[i] = ref[i];\n\t\t\t}\n\t}\n\n\tif (options.vnode) options.vnode(vnode);\n\treturn vnode;\n}\n\n/**\n * Create a template vnode. This function is not expected to be\n * used directly, but rather through a precompile JSX transform\n * @param {string[]} templates\n * @param  {Array<string | null | VNode>} exprs\n * @returns {VNode}\n */\nfunction jsxTemplate(templates, ...exprs) {\n\tconst vnode = createVNode(Fragment, { tpl: templates, exprs });\n\t// Bypass render to string top level Fragment optimization\n\tvnode.key = vnode._vnode;\n\treturn vnode;\n}\n\nconst JS_TO_CSS = {};\nconst CSS_REGEX = /[A-Z]/g;\n\n/**\n * Unwrap potential signals.\n * @param {*} value\n * @returns {*}\n */\nfunction normalizeAttrValue(value) {\n\treturn value !== null &&\n\t\ttypeof value === 'object' &&\n\t\ttypeof value.valueOf === 'function'\n\t\t? value.valueOf()\n\t\t: value;\n}\n\n/**\n * Serialize an HTML attribute to a string. This function is not\n * expected to be used directly, but rather through a precompile\n * JSX transform\n * @param {string} name The attribute name\n * @param {*} value The attribute value\n * @returns {string}\n */\nfunction jsxAttr(name, value) {\n\tif (options.attr) {\n\t\tconst result = options.attr(name, value);\n\t\tif (typeof result === 'string') return result;\n\t}\n\n\tvalue = normalizeAttrValue(value);\n\n\tif (name === 'ref' || name === 'key') return '';\n\tif (name === 'style' && typeof value === 'object') {\n\t\tlet str = '';\n\t\tfor (let prop in value) {\n\t\t\tlet val = value[prop];\n\t\t\tif (val != null && val !== '') {\n\t\t\t\tconst name =\n\t\t\t\t\tprop[0] == '-'\n\t\t\t\t\t\t? prop\n\t\t\t\t\t\t: JS_TO_CSS[prop] ||\n\t\t\t\t\t\t\t(JS_TO_CSS[prop] = prop.replace(CSS_REGEX, '-$&').toLowerCase());\n\n\t\t\t\tlet suffix = ';';\n\t\t\t\tif (\n\t\t\t\t\ttypeof val === 'number' &&\n\t\t\t\t\t// Exclude custom-attributes\n\t\t\t\t\t!name.startsWith('--') &&\n\t\t\t\t\t!IS_NON_DIMENSIONAL.test(name)\n\t\t\t\t) {\n\t\t\t\t\tsuffix = 'px;';\n\t\t\t\t}\n\t\t\t\tstr = str + name + ':' + val + suffix;\n\t\t\t}\n\t\t}\n\t\treturn name + '=\"' + encodeEntities(str) + '\"';\n\t}\n\n\tif (\n\t\tvalue == null ||\n\t\tvalue === false ||\n\t\ttypeof value === 'function' ||\n\t\ttypeof value === 'object'\n\t) {\n\t\treturn '';\n\t} else if (value === true) return name;\n\n\treturn name + '=\"' + encodeEntities('' + value) + '\"';\n}\n\n/**\n * Escape a dynamic child passed to `jsxTemplate`. This function\n * is not expected to be used directly, but rather through a\n * precompile JSX transform\n * @param {*} value\n * @returns {string | null | VNode | Array<string | null | VNode>}\n */\nfunction jsxEscape(value) {\n\tif (\n\t\tvalue == null ||\n\t\ttypeof value === 'boolean' ||\n\t\ttypeof value === 'function'\n\t) {\n\t\treturn null;\n\t}\n\n\tif (typeof value === 'object') {\n\t\t// Check for VNode\n\t\tif (value.constructor === undefined) return value;\n\n\t\tif (isArray(value)) {\n\t\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\t\tvalue[i] = jsxEscape(value[i]);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t}\n\n\treturn encodeEntities('' + value);\n}\n\nexport {\n\tcreateVNode as jsx,\n\tcreateVNode as jsxs,\n\tcreateVNode as jsxDEV,\n\tFragment,\n\t// precompiled JSX transform\n\tjsxTemplate,\n\tjsxAttr,\n\tjsxEscape\n};\n", "import { render } from 'preact';\nimport { useState, useEffect, useRef, useCallback } from 'preact/hooks';\nimport { analyzeRegionShape, createRegion, RegionCandidate } from './regions.js';\nimport { getFloodFillCandidates, FloodFillResult, getMostCommonPerimeterColor, findTransparentPixels } from './floodFill.js';\nimport { inferGrid, assignGridPositions, generateOutput, Grid } from './grid.js';\nimport { kMeansCluster, RGB } from './colors.js';\nimport { AppState, loadState, saveState, getDefaultState } from './state.js';\n\n// Get version and commit hash from the build\ndeclare const __VERSION__: string;\ndeclare const __COMMIT_HASH__: string;\n\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : '0.1.0';\nconst COMMIT_HASH = typeof __COMMIT_HASH__ !== 'undefined' ? __COMMIT_HASH__ : 'dev';\n\nfunction App() {\n  const [state, setState] = useState<AppState>(loadState);\n  const [image, setImage] = useState<HTMLImageElement | null>(null);\n  const [imageData, setImageData] = useState<ImageData | null>(null);\n  const [tool, setTool] = useState<'add' | 'delete'>('add');\n  const [hoveredRegion, setHoveredRegion] = useState<string | null>(null);\n  const [candidateModal, setCandidateModal] = useState<{\n    result: FloodFillResult;\n    candidates: RegionCandidate[];\n  } | null>(null);\n  const [grid, setGrid] = useState<Grid | null>(null);\n  const [outputImageData, setOutputImageData] = useState<ImageData | null>(null);\n  const [outputZoom, setOutputZoom] = useState(4);\n  \n  const inputCanvasRef = useRef<HTMLCanvasElement>(null);\n  const outputCanvasRef = useRef<HTMLCanvasElement>(null);\n\n  // Load image from state\n  useEffect(() => {\n    if (state.imageDataUrl && !image) {\n      const img = new Image();\n      img.onload = () => {\n        setImage(img);\n      };\n      img.src = state.imageDataUrl;\n    }\n  }, [state.imageDataUrl, image]);\n\n  // Get image data when image loads\n  useEffect(() => {\n    if (image && inputCanvasRef.current) {\n      const canvas = inputCanvasRef.current;\n      canvas.width = image.width;\n      canvas.height = image.height;\n      const ctx = canvas.getContext('2d')!;\n      ctx.drawImage(image, 0, 0);\n      setImageData(ctx.getImageData(0, 0, image.width, image.height));\n    }\n  }, [image]);\n\n  // Save state on change\n  useEffect(() => {\n    saveState(state);\n  }, [state]);\n\n  // Infer grid when regions change\n  useEffect(() => {\n    if (imageData && state.regions.length >= 4) {\n      const result = inferGrid(state.regions, imageData.width, imageData.height);\n      if (result.grid) {\n        setGrid(result.grid);\n        // Assign grid positions to regions\n        const updated = assignGridPositions(state.regions, result.grid);\n        if (JSON.stringify(updated) !== JSON.stringify(state.regions)) {\n          setState(s => ({ ...s, regions: updated }));\n        }\n      } else {\n        console.log('Failed to infer grid');\n      }\n    } else {\n        console.log('Not enough regions yet');\n      setGrid(null);\n    }\n  }, [state.regions, imageData]);\n\n  // Generate output when grid or settings change\n  useEffect(() => {\n    if (!imageData || !grid) {\n      console.log(imageData);\n      console.log(grid);\n      setOutputImageData(null);\n      return;\n    }\n\n    // Calculate transparency pixels if enabled\n    let transparentPixels: Set<string> | null = null;\n    if (state.inferTransparency) {\n      const perimeterColor = getMostCommonPerimeterColor(imageData);\n      transparentPixels = findTransparentPixels(imageData, perimeterColor, state.transparencyThreshold);\n    }\n\n    // Calculate color centroids if color limiting is enabled\n    let colorCentroids: RGB[] | null = null;\n    if (state.maxColors && state.maxColors > 0) {\n      const allColors: RGB[] = [];\n      for (let y = 0; y < imageData.height; y += 4) {\n        for (let x = 0; x < imageData.width; x += 4) {\n          const idx = (y * imageData.width + x) * 4;\n          allColors.push({\n            r: imageData.data[idx],\n            g: imageData.data[idx + 1],\n            b: imageData.data[idx + 2]\n          });\n        }\n      }\n      colorCentroids = kMeansCluster(allColors, state.maxColors);\n    }\n\n    const output = generateOutput(imageData, grid, state.regions, transparentPixels, colorCentroids);\n    setOutputImageData(output);\n  }, [imageData, grid, state.regions, state.inferTransparency, state.transparencyThreshold, state.maxColors]);\n\n  // Render input canvas with regions\n  useEffect(() => {\n    if (!inputCanvasRef.current || !image) return;\n    \n    const canvas = inputCanvasRef.current;\n    const ctx = canvas.getContext('2d')!;\n    \n    // Draw image\n    ctx.drawImage(image, 0, 0);\n    \n    // Draw grid overlay if available\n    if (grid) {\n      ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';\n      ctx.lineWidth = 1;\n      \n      for (let x = 0; x <= grid.width; x++) {\n        const px = grid.offsetX + x * grid.pitchX - grid.pitchX / 2;\n        ctx.beginPath();\n        ctx.moveTo(px, 0);\n        ctx.lineTo(px, canvas.height);\n        ctx.stroke();\n      }\n      \n      for (let y = 0; y <= grid.height; y++) {\n        const py = grid.offsetY + y * grid.pitchY - grid.pitchY / 2;\n        ctx.beginPath();\n        ctx.moveTo(0, py);\n        ctx.lineTo(canvas.width, py);\n        ctx.stroke();\n      }\n    }\n    \n    // Draw region outlines\n    for (const region of state.regions) {\n      const isHovered = region.id === hoveredRegion;\n      ctx.strokeStyle = isHovered ? 'rgba(255, 200, 100, 0.9)' : 'rgba(100, 200, 255, 0.6)';\n      ctx.lineWidth = isHovered ? 2 : 1;\n      \n      // Draw outline around region bounds\n      const { minX, minY, maxX, maxY } = region.bounds;\n      ctx.strokeRect(minX - 1, minY - 1, maxX - minX + 3, maxY - minY + 3);\n    }\n  }, [image, grid, state.regions, hoveredRegion]);\n\n  // Render output canvas\n  useEffect(() => {\n    if (!outputCanvasRef.current || !outputImageData) return;\n    \n    const canvas = outputCanvasRef.current;\n    const ctx = canvas.getContext('2d')!;\n    \n    canvas.width = outputImageData.width * outputZoom;\n    canvas.height = outputImageData.height * outputZoom;\n    \n    // Draw checkerboard for transparency\n    const checkSize = outputZoom / 2;\n    for (let y = 0; y < canvas.height; y += checkSize) {\n      for (let x = 0; x < canvas.width; x += checkSize) {\n        const isLight = ((x / checkSize) + (y / checkSize)) % 2 === 0;\n        ctx.fillStyle = isLight ? '#444' : '#666';\n        ctx.fillRect(x, y, checkSize, checkSize);\n      }\n    }\n    \n    // Draw output image scaled up\n    ctx.imageSmoothingEnabled = false;\n    const tempCanvas = document.createElement('canvas');\n    tempCanvas.width = outputImageData.width;\n    tempCanvas.height = outputImageData.height;\n    const tempCtx = tempCanvas.getContext('2d')!;\n    tempCtx.putImageData(outputImageData, 0, 0);\n    ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);\n    \n    // Draw grid lines\n    ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';\n    ctx.lineWidth = 1;\n    \n    for (let x = 0; x <= outputImageData.width; x++) {\n      ctx.beginPath();\n      ctx.moveTo(x * outputZoom, 0);\n      ctx.lineTo(x * outputZoom, canvas.height);\n      ctx.stroke();\n    }\n    \n    for (let y = 0; y <= outputImageData.height; y++) {\n      ctx.beginPath();\n      ctx.moveTo(0, y * outputZoom);\n      ctx.lineTo(canvas.width, y * outputZoom);\n      ctx.stroke();\n    }\n  }, [outputImageData, outputZoom]);\n\n  const handleImageLoad = useCallback((file: File) => {\n    const reader = new FileReader();\n    reader.onload = (e) => {\n      const dataUrl = e.target?.result as string;\n      const img = new Image();\n      img.onload = () => {\n        setImage(img);\n        setState(s => ({ ...s, imageDataUrl: dataUrl, regions: [] }));\n        setGrid(null);\n      };\n      img.src = dataUrl;\n    };\n    reader.readAsDataURL(file);\n  }, []);\n\n  const handlePaste = useCallback((e: ClipboardEvent) => {\n    const items = e.clipboardData?.items;\n    if (!items) return;\n    \n    for (const item of items) {\n      if (item.type.startsWith('image/')) {\n        const file = item.getAsFile();\n        if (file) {\n          handleImageLoad(file);\n          break;\n        }\n      }\n    }\n  }, [handleImageLoad]);\n\n  useEffect(() => {\n    document.addEventListener('paste', handlePaste);\n    return () => document.removeEventListener('paste', handlePaste);\n  }, [handlePaste]);\n\n  const handleDrop = useCallback((e: DragEvent) => {\n    e.preventDefault();\n    const file = e.dataTransfer?.files[0];\n    if (file && file.type.startsWith('image/')) {\n      handleImageLoad(file);\n    }\n  }, [handleImageLoad]);\n\n  const handleCanvasClick = useCallback((e: MouseEvent) => {\n    if (!imageData || !inputCanvasRef.current) return;\n    \n    const rect = inputCanvasRef.current.getBoundingClientRect();\n    const scaleX = imageData.width / rect.width;\n    const scaleY = imageData.height / rect.height;\n    const x = Math.floor((e.clientX - rect.left) * scaleX);\n    const y = Math.floor((e.clientY - rect.top) * scaleY);\n    \n    if (tool === 'delete') {\n      // Find region containing this point\n      for (const region of state.regions) {\n        if (region.pixels.has(`${x},${y}`)) {\n          setState(s => ({\n            ...s,\n            regions: s.regions.filter(r => r.id !== region.id)\n          }));\n          return;\n        }\n      }\n    } else {\n      // Add mode - flood fill\n      const candidates = getFloodFillCandidates(imageData, x, y);\n      \n      // Pick the best candidate (medium threshold usually works best)\n      const result = candidates[1] || candidates[0];\n      \n      // Analyze shape candidates\n      const shapeCandidates = analyzeRegionShape(result, imageData);\n      \n      if (shapeCandidates.length === 0) return;\n      \n      // If one candidate is clearly the best (score > 0.8 and 20% better than second)\n      if (shapeCandidates[0].score > 0.8 && \n          (shapeCandidates.length === 1 || shapeCandidates[0].score > shapeCandidates[1].score * 1.2)) {\n        // Auto-select\n        const region = createRegion(result, shapeCandidates[0]);\n        setState(s => ({ ...s, regions: [...s.regions, region] }));\n      } else {\n        // Show modal for user selection\n        setCandidateModal({ result, candidates: shapeCandidates });\n      }\n    }\n  }, [imageData, tool, state.regions]);\n\n  const handleCanvasMouseMove = useCallback((e: MouseEvent) => {\n    if (!imageData || !inputCanvasRef.current) return;\n    \n    const rect = inputCanvasRef.current.getBoundingClientRect();\n    const scaleX = imageData.width / rect.width;\n    const scaleY = imageData.height / rect.height;\n    const x = Math.floor((e.clientX - rect.left) * scaleX);\n    const y = Math.floor((e.clientY - rect.top) * scaleY);\n    \n    // Find region at this point\n    for (const region of state.regions) {\n      if (region.pixels.has(`${x},${y}`)) {\n        setHoveredRegion(region.id);\n        return;\n      }\n    }\n    setHoveredRegion(null);\n  }, [imageData, state.regions]);\n\n  const handleSelectCandidate = useCallback((candidate: RegionCandidate) => {\n    if (!candidateModal) return;\n    \n    const region = createRegion(candidateModal.result, candidate);\n    setState(s => ({ ...s, regions: [...s.regions, region] }));\n    setCandidateModal(null);\n  }, [candidateModal]);\n\n  const handleCopyOutput = useCallback(async () => {\n    if (!outputCanvasRef.current) return;\n    \n    try {\n      const blob = await new Promise<Blob>((resolve, reject) => {\n        outputCanvasRef.current!.toBlob(blob => {\n          if (blob) resolve(blob);\n          else reject(new Error('Failed to create blob'));\n        }, 'image/png');\n      });\n      \n      await navigator.clipboard.write([\n        new ClipboardItem({ 'image/png': blob })\n      ]);\n    } catch (e) {\n      console.error('Failed to copy:', e);\n    }\n  }, []);\n\n  const handleDownloadOutput = useCallback(() => {\n    if (!outputCanvasRef.current || !outputImageData) return;\n    \n    // Create actual size canvas\n    const tempCanvas = document.createElement('canvas');\n    tempCanvas.width = outputImageData.width;\n    tempCanvas.height = outputImageData.height;\n    const ctx = tempCanvas.getContext('2d')!;\n    ctx.putImageData(outputImageData, 0, 0);\n    \n    const link = document.createElement('a');\n    link.download = 'pixel-art.png';\n    link.href = tempCanvas.toDataURL('image/png');\n    link.click();\n  }, [outputImageData]);\n\n  const handleClear = useCallback(() => {\n    setState(getDefaultState());\n    setImage(null);\n    setImageData(null);\n    setGrid(null);\n    setOutputImageData(null);\n  }, []);\n\n  return (\n    <>\n      <header class=\"header\">\n        <h1>\uD83C\uDFA8 Pix - Pixel Image Extractor</h1>\n        <div class=\"toolbar\">\n          <button\n            class={`btn btn-icon ${tool === 'add' ? 'active' : ''}`}\n            onClick={() => setTool('add')}\n            title=\"Add Region\"\n          >\n            \u2795\n          </button>\n          <button\n            class={`btn btn-icon ${tool === 'delete' ? 'active' : ''}`}\n            onClick={() => setTool('delete')}\n            title=\"Delete Region\"\n          >\n            \uD83D\uDDD1\uFE0F\n          </button>\n          <button class=\"btn btn-danger\" onClick={handleClear} disabled={!state.imageDataUrl}>\n            Clear\n          </button>\n        </div>\n      </header>\n      \n      <main class=\"main-container\">\n        <section class=\"panel input-panel\">\n          <div class=\"panel-header\">\n            <h2>Input Image</h2>\n            <span class=\"text-muted\">{state.regions.length} regions</span>\n          </div>\n          \n          {!image ? (\n            <div\n              class=\"drop-zone\"\n              onDrop={handleDrop as unknown as (e: Event) => void}\n              onDragOver={(e) => { e.preventDefault(); (e.currentTarget as HTMLElement).classList.add('dragover'); }}\n              onDragLeave={(e) => (e.currentTarget as HTMLElement).classList.remove('dragover')}\n              onClick={() => {\n                const input = document.createElement('input');\n                input.type = 'file';\n                input.accept = 'image/*';\n                input.onchange = (e) => {\n                  const file = (e.target as HTMLInputElement).files?.[0];\n                  if (file) handleImageLoad(file);\n                };\n                input.click();\n              }}\n            >\n              <div class=\"drop-zone-icon\">\uD83D\uDCC1</div>\n              <p>Drop an image, paste, or click to upload</p>\n            </div>\n          ) : (\n            <div class=\"canvas-container\">\n              <canvas\n                ref={inputCanvasRef}\n                onClick={handleCanvasClick as unknown as (e: Event) => void}\n                onMouseMove={handleCanvasMouseMove as unknown as (e: Event) => void}\n                style={{ cursor: tool === 'delete' ? 'pointer' : 'crosshair' }}\n              />\n            </div>\n          )}\n          \n          <div class=\"settings-panel\">\n            <h3>Settings</h3>\n            <div class=\"setting-row\">\n              <label>Infer Transparency</label>\n              <input\n                type=\"checkbox\"\n                checked={state.inferTransparency}\n                onChange={(e) => setState(s => ({ ...s, inferTransparency: (e.target as HTMLInputElement).checked }))}\n              />\n            </div>\n            {state.inferTransparency && (\n              <div class=\"setting-row\">\n                <label>Threshold</label>\n                <input\n                  type=\"range\"\n                  min=\"1\"\n                  max=\"50\"\n                  value={state.transparencyThreshold}\n                  onChange={(e) => setState(s => ({ ...s, transparencyThreshold: parseInt((e.target as HTMLInputElement).value) }))}\n                />\n                <span>{state.transparencyThreshold}</span>\n              </div>\n            )}\n            <div class=\"setting-row\">\n              <label>Max Colors</label>\n              <input\n                type=\"number\"\n                min=\"0\"\n                max=\"256\"\n                value={state.maxColors || ''}\n                placeholder=\"None\"\n                onChange={(e) => {\n                  const val = parseInt((e.target as HTMLInputElement).value);\n                  setState(s => ({ ...s, maxColors: isNaN(val) || val <= 0 ? null : val }));\n                }}\n              />\n            </div>\n          </div>\n        </section>\n        \n        <section class=\"panel\">\n          <div class=\"panel-header\">\n            <h2>Output Preview</h2>\n            <div class=\"zoom-controls\">\n              <button class=\"btn btn-secondary btn-icon\" onClick={() => setOutputZoom(z => Math.max(1, z - 1))}>-</button>\n              <span class=\"zoom-level\">{outputZoom}x</span>\n              <button class=\"btn btn-secondary btn-icon\" onClick={() => setOutputZoom(z => Math.min(16, z + 1))}>+</button>\n            </div>\n          </div>\n          \n          {outputImageData ? (\n            <>\n              <div class=\"canvas-container\">\n                <canvas ref={outputCanvasRef} class=\"output-canvas\" />\n              </div>\n              <div class=\"toolbar\" style={{ marginTop: '1rem' }}>\n                <button class=\"btn\" onClick={handleCopyOutput}>\n                  \uD83D\uDCCB Copy\n                </button>\n                <button class=\"btn\" onClick={handleDownloadOutput}>\n                  \uD83D\uDCBE Download PNG\n                </button>\n              </div>\n            </>\n          ) : (\n            <div class=\"drop-zone\" style={{ cursor: 'default' }}>\n              <p>Add at least 4 regions to generate output</p>\n              <p class=\"text-muted\">\n                {state.regions.length === 0 \n                  ? 'Click on the input image to start adding regions'\n                  : `${4 - state.regions.length} more needed`}\n              </p>\n            </div>\n          )}\n        </section>\n      </main>\n      \n      {candidateModal && (\n        <div class=\"modal-overlay\" onClick={() => setCandidateModal(null)}>\n          <div class=\"modal\" onClick={(e) => e.stopPropagation()}>\n            <h2>Select Region Shape</h2>\n            <p>Choose the shape that best matches this region:</p>\n            <div class=\"modal-candidates\">\n              {candidateModal.candidates.map((candidate, i) => (\n                <div\n                  key={i}\n                  class=\"candidate\"\n                  onClick={() => handleSelectCandidate(candidate)}\n                >\n                  <div class=\"candidate-preview\">\n                    <div style={{\n                      display: 'grid',\n                      gridTemplateColumns: `repeat(${candidate.gridWidth}, 20px)`,\n                      gap: '2px'\n                    }}>\n                      {Array.from({ length: candidate.gridHeight }).flatMap((_, gy) =>\n                        Array.from({ length: candidate.gridWidth }).map((_, gx) => {\n                          const isFilled = candidate.shapeMask[gy][gx];\n                          const cellColor = candidate.cellColors[gy][gx];\n                          return (\n                            <div key={`${gy}-${gx}`} style={{\n                              width: '20px',\n                              height: '20px',\n                              backgroundColor: isFilled && cellColor\n                                ? `rgb(${cellColor.r}, ${cellColor.g}, ${cellColor.b})`\n                                : 'transparent',\n                              borderRadius: '2px',\n                              border: isFilled ? 'none' : '1px dashed rgba(255,255,255,0.2)'\n                            }} />\n                          );\n                        })\n                      )}\n                    </div>\n                  </div>\n                  <span class=\"candidate-label\">\n                    {candidate.gridWidth}\u00D7{candidate.gridHeight} ({Math.round(candidate.score * 100)}%)\n                  </span>\n                </div>\n              ))}\n            </div>\n            <div class=\"modal-actions\">\n              <button class=\"btn btn-secondary\" onClick={() => setCandidateModal(null)}>\n                Cancel\n              </button>\n            </div>\n          </div>\n        </div>\n      )}\n      \n      <footer class=\"footer\">\n        <span>\n          A vibe-coded micro-app via{' '}\n          <a href=\"https://searyanc.dev\" target=\"_blank\" rel=\"noopener noreferrer\">\n            SeaRyanC\n          </a>\n        </span>\n        <a\n          href=\"https://github.com/SeaRyanC/app/tree/main/pix\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          title=\"View source on GitHub\"\n        >\n          <svg viewBox=\"0 0 16 16\" fill=\"currentColor\">\n            <path d=\"M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z\" />\n          </svg>\n        </a>\n        <span style={{ fontSize: '0.75rem' }}>v{VERSION}+{COMMIT_HASH}</span>\n      </footer>\n    </>\n  );\n}\n\nrender(<App />, document.getElementById('app')!);\n"],
  "mappings": "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",
  "names": ["slice", "options", "vnodeId", "isValidElement", "rerenderQueue", "prevDebounce", "defer", "depthSort", "CAPTURE_REGEX", "eventClock", "eventProxy", "eventProxyCapture", "i", "EMPTY_OBJ", "EMPTY_ARR", "IS_NON_DIMENSIONAL", "isArray", "Array", "assign", "obj", "props", "removeNode", "node", "parentNode", "removeChild", "createElement", "type", "children", "key", "ref", "normalizedProps", "arguments", "length", "call", "defaultProps", "createVNode", "original", "vnode", "__k", "__", "__b", "__e", "__c", "constructor", "__v", "__i", "__u", "Fragment", "props", "children", "BaseComponent", "context", "this", "getDomSibling", "vnode", "childIndex", "__", "__i", "sibling", "__k", "length", "__e", "type", "updateParentDomPointers", "i", "child", "__c", "base", "enqueueRender", "c", "__d", "rerenderQueue", "push", "process", "__r", "prevDebounce", "options", "debounceRendering", "defer", "component", "newVNode", "oldVNode", "oldDom", "commitQueue", "refQueue", "l", "sort", "depthSort", "shift", "__v", "__P", "assign", "diff", "__n", "namespaceURI", "__u", "commitRoot", "diffChildren", "parentDom", "renderResult", "newParentVNode", "oldParentVNode", "globalContext", "namespace", "excessDomChildren", "isHydrating", "childVNode", "newDom", "firstChildDom", "result", "shouldPlace", "oldChildren", "EMPTY_ARR", "newChildrenLength", "constructNewChildrenArray", "EMPTY_OBJ", "ref", "applyRef", "insert", "nextSibling", "skewedIndex", "matchingIndex", "oldChildrenLength", "remainingOldChildren", "skew", "Array", "constructor", "String", "createVNode", "isArray", "__b", "key", "findMatchingIndex", "unmount", "parentVNode", "parentNode", "insertBefore", "nodeType", "findMatchingIndex", "childVNode", "oldChildren", "skewedIndex", "remainingOldChildren", "x", "y", "childIndex", "key", "type", "oldVNode", "matched", "__u", "length", "setStyle", "style", "value", "setProperty", "IS_NON_DIMENSIONAL", "test", "dom", "name", "oldValue", "namespace", "useCapture", "lowerCaseName", "o", "cssText", "replace", "CAPTURE_REGEX", "toLowerCase", "slice", "l", "_attached", "eventClock", "addEventListener", "eventProxyCapture", "eventProxy", "removeEventListener", "e", "removeAttribute", "setAttribute", "createEventProxy", "this", "eventHandler", "_dispatched", "options", "event", "diff", "parentDom", "newVNode", "globalContext", "excessDomChildren", "commitQueue", "oldDom", "isHydrating", "refQueue", "tmp", "c", "isNew", "oldProps", "oldState", "snapshot", "clearProcessingException", "newProps", "isClassComponent", "provider", "componentContext", "i", "renderHook", "count", "renderResult", "newType", "constructor", "__e", "__b", "outer", "props", "prototype", "render", "contextType", "__c", "__", "__E", "BaseComponent", "doRender", "sub", "state", "__n", "__d", "__h", "_sb", "__s", "getDerivedStateFromProps", "assign", "__v", "componentWillMount", "componentDidMount", "push", "componentWillReceiveProps", "shouldComponentUpdate", "__k", "some", "vnode", "componentWillUpdate", "componentDidUpdate", "context", "__P", "__r", "getChildContext", "getSnapshotBeforeUpdate", "Fragment", "cloneNode", "children", "diffChildren", "isArray", "base", "then", "MODE_HYDRATE", "nodeType", "nextSibling", "indexOf", "removeNode", "markAsForce", "diffElementNodes", "diffed", "forEach", "commitRoot", "root", "applyRef", "cb", "call", "node", "map", "newHtml", "oldHtml", "newChildren", "inputValue", "checked", "EMPTY_OBJ", "localName", "document", "createTextNode", "createElementNS", "is", "__m", "data", "childNodes", "attributes", "__html", "innerHTML", "content", "getDomSibling", "undefined", "ref", "hasRefUnmount", "current", "unmount", "parentVNode", "skipRemove", "r", "componentWillUnmount", "replaceNode", "documentElement", "createElement", "namespaceURI", "firstChild", "slice", "EMPTY_ARR", "options", "__e", "error", "vnode", "oldVNode", "errorInfo", "component", "ctor", "handled", "__", "__c", "constructor", "getDerivedStateFromError", "setState", "__d", "componentDidCatch", "__E", "e", "vnodeId", "isValidElement", "BaseComponent", "prototype", "update", "callback", "s", "this", "__s", "state", "assign", "props", "__v", "_sb", "push", "enqueueRender", "forceUpdate", "__h", "render", "Fragment", "rerenderQueue", "defer", "Promise", "then", "bind", "resolve", "setTimeout", "depthSort", "a", "b", "__b", "process", "__r", "CAPTURE_REGEX", "eventClock", "eventProxy", "createEventProxy", "eventProxyCapture", "i", "currentIndex", "currentComponent", "previousComponent", "prevRaf", "currentHook", "afterPaintEffects", "options", "_options", "oldBeforeDiff", "__b", "oldBeforeRender", "__r", "oldAfterDiff", "diffed", "oldCommit", "__c", "oldBeforeUnmount", "unmount", "oldRoot", "__", "getHookState", "index", "type", "__h", "hooks", "__H", "length", "push", "useState", "initialState", "useReducer", "invokeOrReturn", "reducer", "init", "hookState", "_reducer", "action", "currentValue", "__N", "nextValue", "setState", "__f", "updateHookState", "p", "s", "c", "stateHooks", "filter", "x", "every", "prevScu", "call", "this", "shouldUpdate", "props", "forEach", "hookItem", "shouldComponentUpdate", "prevCWU", "componentWillUpdate", "__e", "tmp", "useEffect", "callback", "args", "state", "__s", "argsChanged", "_pendingArgs", "useRef", "initialValue", "currentHook", "useMemo", "current", "useMemo", "factory", "args", "state", "getHookState", "currentIndex", "argsChanged", "__H", "__", "__h", "useCallback", "callback", "currentHook", "flushAfterPaintEffects", "component", "afterPaintEffects", "shift", "__P", "__H", "__h", "forEach", "invokeCleanup", "invokeEffect", "e", "options", "__e", "__v", "__b", "vnode", "currentComponent", "oldBeforeDiff", "__", "parentDom", "__k", "__m", "oldRoot", "__r", "oldBeforeRender", "currentIndex", "hooks", "__c", "previousComponent", "hookItem", "__N", "_pendingArgs", "diffed", "oldAfterDiff", "c", "length", "push", "prevRaf", "requestAnimationFrame", "afterNextFrame", "commitQueue", "some", "filter", "cb", "oldCommit", "unmount", "oldBeforeUnmount", "hasErrored", "s", "HAS_RAF", "callback", "raf", "done", "clearTimeout", "timeout", "cancelAnimationFrame", "setTimeout", "hook", "comp", "cleanup", "argsChanged", "oldArgs", "newArgs", "arg", "index", "invokeOrReturn", "f", "c", "s", "r", "g", "f", "t", "a2", "C2", "G", "T", "x", "m2", "c2", "L", "M", "S", "I", "a", "k", "i", "j", "x", "y", "x", "y", "w", "h", "a", "c", "y", "x", "s", "p", "a", "x", "y", "r", "g", "c", "r", "e", "vnodeId", "isArray", "Array", "createVNode", "type", "props", "key", "isStaticChildren", "__source", "__self", "ref", "i", "normalizedProps", "vnode", "__k", "__", "__b", "__e", "__c", "constructor", "__v", "__i", "__u", "defaultProps", "options", "d", "A", "y", "s", "x", "q", "e", "r", "blob", "u", "z", "i", "_"]
}
